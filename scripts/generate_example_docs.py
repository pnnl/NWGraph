#!/usr/bin/env python3
"""
Generate RST documentation for NWGraph examples from C++ source files.

This script extracts documentation from specially-formatted comments in C++
example files and generates corresponding RST documentation pages.

Usage:
    python generate_example_docs.py [--check] [example.cpp ...]

    --check    Verify docs are up-to-date without modifying files

If no files specified, processes all examples in examples/bgl-book/.

The C++ source files should contain documentation in this format:

    /**
     * @file example.cpp
     * @brief Short title for the example
     *
     * @doc_overview
     * Multi-line overview text that will appear in the Overview section.
     * Can span multiple lines.
     * @end_doc
     *
     * @doc_algorithm
     * Algorithm description text.
     * @end_doc
     *
     * @doc_output
     * Expected output when running the example.
     * @end_doc
     *
     * @doc_features
     * - Feature 1: description
     * - Feature 2: description
     * @end_doc
     */

Code sections can be marked for inclusion:

    // @doc_section: section_name
    ... code ...
    // @end_section

Author: Claude Code (autogenerated)
"""

import re
import sys
import hashlib
from pathlib import Path
from datetime import datetime
from typing import Optional

# Template for generated RST files
RST_TEMPLATE = '''..
   AUTO-GENERATED FILE - DO NOT EDIT DIRECTLY

   This file was generated by scripts/generate_example_docs.py
   from {source_file}

   Source hash: {source_hash}
   Generated: {timestamp}

   To regenerate, run: python scripts/generate_example_docs.py

.. SPDX-FileCopyrightText: 2022 Battelle Memorial Institute
.. SPDX-FileCopyrightText: 2022 University of Washington
..
.. SPDX-License-Identifier: BSD-3-Clause

{title_decoration}
{title}
{title_decoration}

Overview
--------

{overview}

Algorithm Description
--------------------

{algorithm}

NWGraph Implementation
---------------------

{implementation}

Running the Example
------------------

.. code-block:: bash

   cd build/examples/bgl-book
   ./{executable}

Sample Output
------------

.. code-block:: text

{output}

Key NWGraph Features Demonstrated
--------------------------------

{features}

See Also
--------

{see_also}
'''


def compute_file_hash(filepath: Path) -> str:
    """Compute SHA256 hash of file contents."""
    with open(filepath, 'rb') as f:
        return hashlib.sha256(f.read()).hexdigest()[:12]


def extract_doc_section(content: str, section_name: str) -> Optional[str]:
    """Extract a @doc_section from the file header comment."""
    pattern = rf'@doc_{section_name}\s*\n(.*?)@end_doc'
    match = re.search(pattern, content, re.DOTALL)
    if match:
        # Clean up the extracted text (remove leading * from comment lines)
        text = match.group(1)
        lines = []
        for line in text.split('\n'):
            # Remove leading whitespace and * from Doxygen comments
            cleaned = re.sub(r'^\s*\*\s?', '', line)
            lines.append(cleaned)
        return '\n'.join(lines).strip()
    return None


def extract_brief(content: str) -> Optional[str]:
    """Extract @brief from file header."""
    match = re.search(r'@brief\s+(.+?)(?:\n|$)', content)
    if match:
        return match.group(1).strip()
    return None


def extract_file_description(content: str) -> Optional[str]:
    """Extract multi-line description after @brief."""
    # Look for text between @brief line and next @ tag or end of comment
    match = re.search(r'@brief\s+.+?\n\s*\*\s*\n(.*?)(?=@\w+|\*/)', content, re.DOTALL)
    if match:
        text = match.group(1)
        lines = []
        for line in text.split('\n'):
            cleaned = re.sub(r'^\s*\*\s?', '', line)
            if cleaned.strip():
                lines.append(cleaned)
        return '\n'.join(lines).strip()
    return None


def find_code_sections(content: str) -> dict:
    """Find marked code sections with line numbers."""
    sections = {}
    lines = content.split('\n')

    current_section = None
    start_line = None

    for i, line in enumerate(lines, 1):
        if '@doc_section:' in line:
            match = re.search(r'@doc_section:\s*(\w+)', line)
            if match:
                current_section = match.group(1)
                start_line = i + 1
        elif '@end_section' in line and current_section:
            sections[current_section] = (start_line, i - 1)
            current_section = None
            start_line = None

    return sections


def find_main_function(content: str) -> tuple:
    """Find the line range of main() function."""
    lines = content.split('\n')
    start = None
    brace_count = 0

    for i, line in enumerate(lines, 1):
        if start is None and re.match(r'\s*int\s+main\s*\(', line):
            start = i
            brace_count = line.count('{') - line.count('}')
        elif start is not None:
            brace_count += line.count('{') - line.count('}')
            if brace_count == 0:
                return (start, i)

    return (start, len(lines)) if start else (None, None)


def generate_literalinclude(source_path: str, start: int, end: int, caption: str = "") -> str:
    """Generate a literalinclude directive."""
    rel_path = f"../../../../{source_path}"
    result = f".. literalinclude:: {rel_path}\n"
    result += "   :language: cpp\n"
    result += "   :linenos:\n"
    result += f"   :lines: {start}-{end}\n"
    if caption:
        result += f"   :caption: {caption}\n"
    return result


def generate_implementation_section(source_path: str, content: str, sections: dict) -> str:
    """Generate the implementation section with literalinclude directives."""
    lines = content.split('\n')
    total_lines = len(lines)

    parts = []

    # Find header comment end
    header_end = 1
    for i, line in enumerate(lines, 1):
        if '*/' in line:
            header_end = i
            break

    # Include the includes section (after header, before main code)
    includes_end = header_end
    for i, line in enumerate(lines[header_end:], header_end + 1):
        if line.strip() and not line.startswith('#include') and not line.startswith('using'):
            includes_end = i - 1
            break

    if includes_end > header_end:
        parts.append(generate_literalinclude(source_path, 1, min(includes_end + 5, total_lines),
                                             "File header and includes"))

    # Find main function
    main_start, main_end = find_main_function(content)
    if main_start:
        parts.append(f"\nThe main function demonstrates the algorithm:\n\n")
        parts.append(generate_literalinclude(source_path, main_start, main_end,
                                             "Main function"))

    return '\n'.join(parts)


def generate_rst(source_file: Path, output_dir: Path) -> str:
    """Generate RST documentation for a C++ example file."""

    with open(source_file, 'r') as f:
        content = f.read()

    # Extract metadata
    brief = extract_brief(content) or source_file.stem
    description = extract_file_description(content) or ""

    # Extract documentation sections (if present)
    overview = extract_doc_section(content, 'overview')
    algorithm = extract_doc_section(content, 'algorithm')
    output = extract_doc_section(content, 'output')
    features = extract_doc_section(content, 'features')
    see_also = extract_doc_section(content, 'see_also')

    # Find code sections
    sections = find_code_sections(content)

    # Generate default content if sections not found
    if not overview:
        overview = description if description else f"This example demonstrates {brief}."

    if not algorithm:
        algorithm = "See the source code for algorithm details."

    if not output:
        output = "   (Run the example to see output)"
    else:
        # Indent output for code block
        output = '\n'.join('   ' + line for line in output.split('\n'))

    if not features:
        features = "- See source code for NWGraph features used"

    if not see_also:
        see_also = "- :doc:`index` - BGL Book examples overview"

    # Generate implementation section
    source_rel = f"examples/bgl-book/{source_file.name}"
    implementation = generate_implementation_section(source_rel, content, sections)

    # Compute title decoration
    title = brief
    title_decoration = '=' * len(title)

    # Fill template
    rst_content = RST_TEMPLATE.format(
        source_file=source_rel,
        source_hash=compute_file_hash(source_file),
        timestamp=datetime.now().strftime('%Y-%m-%d %H:%M:%S'),
        title=title,
        title_decoration=title_decoration,
        overview=overview,
        algorithm=algorithm,
        implementation=implementation,
        executable=source_file.stem,
        output=output,
        features=features,
        see_also=see_also
    )

    return rst_content


def get_rst_hash(rst_file: Path) -> Optional[str]:
    """Extract the source hash from an existing RST file."""
    if not rst_file.exists():
        return None

    with open(rst_file, 'r') as f:
        content = f.read()

    match = re.search(r'Source hash: (\w+)', content)
    return match.group(1) if match else None


def main():
    """Main entry point."""
    check_only = '--check' in sys.argv
    args = [a for a in sys.argv[1:] if not a.startswith('--')]

    # Find project root
    script_dir = Path(__file__).parent
    project_root = script_dir.parent

    examples_dir = project_root / 'examples' / 'bgl-book'
    output_dir = project_root / 'doc-src' / 'sphinx' / 'examples' / 'bglbook'

    # Get source files to process
    if args:
        source_files = [Path(a) for a in args]
    else:
        source_files = sorted(examples_dir.glob('ch*.cpp'))

    if not source_files:
        print("No example files found")
        return 1

    updates_needed = []

    for source_file in source_files:
        if not source_file.exists():
            print(f"Warning: {source_file} not found")
            continue

        rst_file = output_dir / f"{source_file.stem}.rst"
        source_hash = compute_file_hash(source_file)
        existing_hash = get_rst_hash(rst_file)

        if existing_hash == source_hash:
            print(f"✓ {source_file.name} - up to date")
            continue

        if check_only:
            updates_needed.append(source_file.name)
            status = "NEW" if existing_hash is None else "OUTDATED"
            print(f"✗ {source_file.name} - {status}")
        else:
            print(f"→ Generating {rst_file.name} from {source_file.name}")
            rst_content = generate_rst(source_file, output_dir)

            output_dir.mkdir(parents=True, exist_ok=True)
            with open(rst_file, 'w') as f:
                f.write(rst_content)

    if check_only and updates_needed:
        print(f"\n{len(updates_needed)} file(s) need regeneration.")
        print("Run without --check to update.")
        return 1

    return 0


if __name__ == '__main__':
    sys.exit(main())
