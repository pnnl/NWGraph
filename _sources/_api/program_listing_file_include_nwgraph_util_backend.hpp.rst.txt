
.. _program_listing_file_include_nwgraph_util_backend.hpp:

Program Listing for File backend.hpp
====================================

|exhale_lsh| :ref:`Return to documentation for file <file_include_nwgraph_util_backend.hpp>` (``include/nwgraph/util/backend.hpp``)

.. |exhale_lsh| unicode:: U+021B0 .. UPWARDS ARROW WITH TIP LEFTWARDS

.. code-block:: cpp

   
   #ifndef NW_GRAPH_BACKEND_HPP
   #define NW_GRAPH_BACKEND_HPP
   
   #include <cstddef>
   
   // Backend selection: HPX or TBB (default)
   // Define NWGRAPH_BACKEND_HPX to use HPX, otherwise TBB is used
   #if defined(NWGRAPH_BACKEND_HPX)
   
     #include <hpx/local/init.hpp>
     #include <hpx/modules/algorithms.hpp>
     #include <hpx/modules/execution.hpp>
     #include <hpx/modules/runtime_local.hpp>
     #include <hpx/parallel/algorithms/for_each.hpp>
     #include <hpx/parallel/algorithms/for_loop.hpp>
     #include <hpx/parallel/algorithms/reduce.hpp>
     #include <hpx/parallel/algorithms/transform_reduce.hpp>
   
     #define NWGRAPH_PARALLEL_BACKEND "HPX"
     #define NWGRAPH_BACKEND_HPX_ENABLED 1
     #define NWGRAPH_BACKEND_TBB_ENABLED 0
   
   #else
     // Default to TBB
     #ifndef NWGRAPH_BACKEND_TBB
       #define NWGRAPH_BACKEND_TBB
     #endif
   
     #include <oneapi/tbb.h>
     #include <tbb/blocked_range.h>
     #include <tbb/parallel_for.h>
     #include <tbb/parallel_for_each.h>
     #include <tbb/parallel_reduce.h>
   
     #define NWGRAPH_PARALLEL_BACKEND "TBB"
     #define NWGRAPH_BACKEND_HPX_ENABLED 0
     #define NWGRAPH_BACKEND_TBB_ENABLED 1
   
   #endif
   
   namespace nw {
   namespace graph {
   
   namespace backend {
   
   inline constexpr const char* name() noexcept {
     return NWGRAPH_PARALLEL_BACKEND;
   }
   
   inline constexpr bool is_tbb() noexcept {
     return NWGRAPH_BACKEND_TBB_ENABLED;
   }
   
   inline constexpr bool is_hpx() noexcept {
     return NWGRAPH_BACKEND_HPX_ENABLED;
   }
   
   #if defined(NWGRAPH_BACKEND_HPX)
   
   namespace detail {
   
   class hpx_runtime_manager {
   public:
     static hpx_runtime_manager& instance() {
       static hpx_runtime_manager mgr;
       return mgr;
     }
   
     void ensure_initialized() {
       if (!initialized_.load(std::memory_order_acquire)) {
         std::lock_guard<std::mutex> lock(mutex_);
         if (!initialized_.load(std::memory_order_relaxed)) {
           if (!hpx::is_running()) {
             // Start HPX local runtime (no networking)
             // Using nullptr for argc/argv starts with default settings
             started_by_us_ = true;
             hpx::local::start(nullptr, 0, nullptr);
           }
           initialized_.store(true, std::memory_order_release);
         }
       }
     }
   
     bool is_initialized() const noexcept {
       return initialized_.load(std::memory_order_acquire);
     }
   
   private:
     hpx_runtime_manager() = default;
   
     ~hpx_runtime_manager() {
       // Only stop HPX if we started it
       if (started_by_us_ && hpx::is_running()) {
         hpx::local::finalize();
       }
     }
   
     // Non-copyable, non-movable
     hpx_runtime_manager(const hpx_runtime_manager&) = delete;
     hpx_runtime_manager& operator=(const hpx_runtime_manager&) = delete;
   
     std::atomic<bool> initialized_{false};
     std::mutex mutex_;
     bool started_by_us_{false};
   };
   
   } // namespace detail
   
   inline void ensure_initialized() {
     detail::hpx_runtime_manager::instance().ensure_initialized();
   }
   
   inline bool is_initialized() noexcept {
     return detail::hpx_runtime_manager::instance().is_initialized();
   }
   
   #else // TBB backend
   
   inline void ensure_initialized() noexcept {
     // TBB initializes automatically on first use - nothing to do
   }
   
   inline bool is_initialized() noexcept {
     return true;  // TBB auto-initializes
   }
   
   #endif // NWGRAPH_BACKEND_HPX
   
   class init_guard {
   public:
     init_guard() {
       ensure_initialized();
     }
   };
   
   } // namespace backend
   } // namespace graph
   } // namespace nw
   
   #endif // NW_GRAPH_BACKEND_HPP
