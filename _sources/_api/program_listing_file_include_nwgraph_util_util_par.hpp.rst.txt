
.. _program_listing_file_include_nwgraph_util_util_par.hpp:

Program Listing for File util_par.hpp
=====================================

|exhale_lsh| :ref:`Return to documentation for file <file_include_nwgraph_util_util_par.hpp>` (``include/nwgraph/util/util_par.hpp``)

.. |exhale_lsh| unicode:: U+021B0 .. UPWARDS ARROW WITH TIP LEFTWARDS

.. code-block:: cpp

   
   #ifndef NW_GRAPH_UTIL_PAR_HPP
   #define NW_GRAPH_UTIL_PAR_HPP
   
   #include <atomic>
   #include <cstddef>
   #include <iterator>
   #include <mutex>
   
   namespace nw {
   namespace graph {
   
   std::mutex mtx;
   
   class par_counting_output_iterator : public std::iterator<std::random_access_iterator_tag, size_t> {
   public:
     par_counting_output_iterator(size_t& count) : count { count } {
     }
     void operator++() {
     }
     void operator++(int) {
     }
     par_counting_output_iterator& operator*() {
       return *this;
     }
     par_counting_output_iterator& operator[](size_t) {
       return *this;
     }
   
     template <typename T>
     void operator=(T) {
       std::lock_guard<std::mutex> lock(mtx);
       count++;
     }
     size_t get_count() {
       return count;
     }
   
   private:
     size_t& count;
   };
   
   class atomic_counting_output_iterator : public std::iterator<std::random_access_iterator_tag, size_t> {
   public:
     explicit atomic_counting_output_iterator(std::atomic<size_t>& count) : count { count } {
     }
     void operator++() {
     }
     void operator++(int) {
     }
     atomic_counting_output_iterator& operator*() {
       return *this;
     }
     atomic_counting_output_iterator& operator[](size_t) {
       return *this;
     }
   
     template <typename T>
     void operator=(T) {
       count++;
     }
     size_t get_count() {
       return count;
     }
   
   private:
     std::atomic<size_t>& count;
   };
   
   typedef size_t vertex_id_type;
   
   }    // namespace graph
   }    // namespace nw
   
   #endif    // NW_GRAPH_UTIL_PAR_HPP
