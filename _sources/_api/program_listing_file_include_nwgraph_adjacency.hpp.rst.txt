
.. _program_listing_file_include_nwgraph_adjacency.hpp:

Program Listing for File adjacency.hpp
======================================

|exhale_lsh| :ref:`Return to documentation for file <file_include_nwgraph_adjacency.hpp>` (``include/nwgraph/adjacency.hpp``)

.. |exhale_lsh| unicode:: U+021B0 .. UPWARDS ARROW WITH TIP LEFTWARDS

.. code-block:: cpp

   #include <nwgraph/edge_list.hpp>
   
   // Create an edge list with 6 vertices
   nw::graph::edge_list<nw::graph::directedness::directed> edges(6);
   edges.push_back(0, 1);
   edges.push_back(0, 2);
   edges.push_back(1, 3);
   edges.push_back(2, 3);
   edges.close();
   
   // Build CSR adjacency from edge list (idx=0 for forward direction)
   nw::graph::adjacency<0> graph(edges);
   
   // Iterate over neighbors of vertex 0
   for (auto&& [neighbor] : graph[0]) {
       std::cout << "0 -> " << neighbor << std::endl;
   }
   
   // Weighted graph example
   nw::graph::edge_list<nw::graph::directedness::directed, double> weighted_edges(6);
   weighted_edges.push_back(0, 1, 1.5);
   weighted_edges.push_back(0, 2, 2.0);
   weighted_edges.close();
   
   nw::graph::adjacency<0, double> weighted_graph(weighted_edges);
   for (auto&& [neighbor, weight] : weighted_graph[0]) {
       std::cout << "0 -> " << neighbor << " (weight: " << weight << ")" << std::endl;
   }
   
   #ifndef NW_GRAPH_ADJACENCY_HPP
   #define NW_GRAPH_ADJACENCY_HPP
   
   #include "nwgraph/containers/compressed.hpp"
   #include "nwgraph/edge_list.hpp"
   #include "nwgraph/graph_base.hpp"
   #include "nwgraph/graph_concepts.hpp"
   #include "nwgraph/util/defaults.hpp"
   
   #include "nwgraph/build.hpp"
   
   #include <concepts>
   
   #include "nwgraph/graph_concepts.hpp"
   
   
   namespace nw {
   namespace graph {
   
   template <int idx, std::unsigned_integral index_type, std::unsigned_integral vertex_id, typename... Attributes>
   class index_adjacency : public unipartite_graph_base, public indexed_struct_of_arrays<index_type, vertex_id, Attributes...> {
     using base = indexed_struct_of_arrays<index_type, vertex_id, Attributes...>;
   
   public:
     using index_t           = index_type;
     using vertex_id_type    = vertex_id;
     using num_vertices_type = std::array<vertex_id_type, 1>;
     using num_edges_type    = index_t;
   
     // The first index_t isn't considered an attribute.
     using attributes_t = std::tuple<Attributes...>;
     static constexpr std::size_t getNAttr() {
       return sizeof...(Attributes);
     }
     index_adjacency(size_t N = 0, size_t M = 0)
       requires(std::is_same<unipartite_graph_base, unipartite_graph_base>::value)
         : unipartite_graph_base(N), base(N, M) {
     }
     //  index_adjacency(std::array<size_t, 1> N, size_t M = 0) requires(std::is_same<unipartite_graph_base, unipartite_graph_base>::value) : unipartite_graph_base(N), base(N[0], M) {}
   
     template <class ExecutionPolicy = std::execution::parallel_unsequenced_policy>
     index_adjacency(index_edge_list<vertex_id_type, unipartite_graph_base, directedness::directed, Attributes...>& A, bool sort_adjacency = false,
                     ExecutionPolicy&& policy = {})
       requires(std::is_same<unipartite_graph_base, unipartite_graph_base>::value)
         : unipartite_graph_base(A.num_vertices()[0]), base(A.num_vertices()[0] + 1) {
       fill<idx>(A, *this, sort_adjacency, policy);
     }
   
     template <class ExecutionPolicy = std::execution::parallel_unsequenced_policy>
     index_adjacency(index_edge_list<vertex_id_type, unipartite_graph_base, directedness::undirected, Attributes...>& A,
                     bool sort_adjacency = false, ExecutionPolicy&& policy = {})
       requires(std::is_same<unipartite_graph_base, unipartite_graph_base>::value)
         : unipartite_graph_base(A.num_vertices()[0]), base(A.num_vertices()[0] + 1) {
       fill<idx>(A, *this, sort_adjacency, policy);
     }
   
     template <class ExecutionPolicy = std::execution::parallel_unsequenced_policy>
     index_adjacency(size_t N, index_edge_list<vertex_id_type, unipartite_graph_base, directedness::directed, Attributes...>& A,
                     bool sort_adjacency = false, ExecutionPolicy&& policy = {})
       requires(std::is_same<unipartite_graph_base, unipartite_graph_base>::value)
         : unipartite_graph_base(N), base(N) {
       fill<idx>(A, *this, sort_adjacency, policy);
     }
     template <class ExecutionPolicy = std::execution::parallel_unsequenced_policy>
     index_adjacency(size_t N, index_edge_list<vertex_id_type, unipartite_graph_base, directedness::undirected, Attributes...>& A,
                     bool sort_adjacency = false, ExecutionPolicy&& policy = {})
       requires(std::is_same<unipartite_graph_base, unipartite_graph_base>::value)
         : unipartite_graph_base(N), base(N) {
       fill<idx>(A, *this, sort_adjacency, policy);
     }
     // customized move constructor
     index_adjacency(std::vector<vertex_id>&& indices, std::vector<vertex_id>&& first_to_be, std::vector<Attributes>&&... rest_to_be)
       requires(std::is_same<unipartite_graph_base, unipartite_graph_base>::value)
         : unipartite_graph_base(indices.size() - 1), base(std::move(indices), std::move(first_to_be), std::move(rest_to_be)...) {
     }
     index_adjacency(std::vector<vertex_id>&& indices, std::tuple<std::vector<vertex_id>, std::vector<Attributes>...>&& to_be_indexed)
       requires(std::is_same<unipartite_graph_base, unipartite_graph_base>::value)
         : unipartite_graph_base(indices.size() - 1), base(std::move(indices), std::move(to_be_indexed)) {
     }
     // customized copy constructor
     index_adjacency(const std::vector<vertex_id>& indices, const std::vector<vertex_id>& first_to_be,
                     const std::vector<Attributes>&... rest_to_be)
       requires(std::is_same<unipartite_graph_base, unipartite_graph_base>::value)
         : unipartite_graph_base(indices.size() - 1), base(indices, first_to_be, rest_to_be...) {
     }
     index_adjacency(const std::vector<vertex_id>& indices, const std::tuple<std::vector<vertex_id>, std::vector<Attributes>...>& to_be_indexed)
       requires(std::is_same<unipartite_graph_base, unipartite_graph_base>::value)
         : unipartite_graph_base(indices.size() - 1), base(indices, to_be_indexed) {
     }
   
     num_vertices_type num_vertices() const {
       return { base::size() };
     };
     num_edges_type num_edges() const {
       return base::to_be_indexed_.size();
     };
     void serialize(const std::string& outfile_name) const {
       std::ofstream out_file(outfile_name, std::ofstream::binary);
       unipartite_graph_base::serialize(out_file);
       base::serialize(out_file);
     }
   
     void deserialize(const std::string& infile_name) {
       std::ifstream infile(infile_name, std::ifstream::binary);
       unipartite_graph_base::deserialize(infile);
       base::deserialize(infile);
     }
   };
   
   template <int idx, typename... Attributes>
   using adjacency = index_adjacency<idx, default_index_t, default_vertex_id_type, Attributes...>;
   
   template <int idx, edge_list_graph edge_list_t>
   auto make_adjacency(edge_list_t& el) {
     return adjacency<idx>(el);
   }
   
   
   template <int idx, edge_list_c edge_list_t, std::unsigned_integral u_integral,
             class ExecutionPolicy = std::execution::parallel_unsequenced_policy>
   auto make_adjacency(edge_list_t& el, u_integral n, directedness edge_directedness = directedness::directed, ExecutionPolicy&& policy = {}) {
     adjacency<idx> adj(n);
     fill<idx>(el, adj, edge_directedness, policy);
     return adj;
   }
   
   template <int idx, std::unsigned_integral index_type, std::unsigned_integral vertex_id, typename... Attributes>
   class index_biadjacency : public bipartite_graph_base, public indexed_struct_of_arrays<index_type, vertex_id, Attributes...> {
     using base = indexed_struct_of_arrays<index_type, vertex_id, Attributes...>;
   
   public:
     using index_t           = index_type;
     using vertex_id_type    = vertex_id;
     using num_vertices_type = std::array<vertex_id_type, 2>;
     using num_edges_type    = index_t;
   
     // The first index_t isn't considered an attribute.
     using attributes_t = std::tuple<Attributes...>;
     static constexpr std::size_t getNAttr() {
       return sizeof...(Attributes);
     }
   
     index_biadjacency(size_t N0 = 0, size_t N1 = 0, size_t M = 0)
       requires(std::is_same<bipartite_graph_base, bipartite_graph_base>::value)
         : bipartite_graph_base(N0, N1), base(N0, M) {
     }
     index_biadjacency(std::array<size_t, 2> N, size_t M = 0)
       requires(std::is_same<bipartite_graph_base, bipartite_graph_base>::value)
         : bipartite_graph_base(N[idx], N[(idx + 1) % 2]), base(N[idx], M) {
     }
   
     template <class ExecutionPolicy = std::execution::parallel_unsequenced_policy>
     index_biadjacency(index_edge_list<vertex_id_type, bipartite_graph_base, directedness::directed, Attributes...>& A,
                       bool sort_biadjacency = false, ExecutionPolicy&& policy = {})
       requires(std::is_same<bipartite_graph_base, bipartite_graph_base>::value)
         : bipartite_graph_base(A.num_vertices()[idx], A.num_vertices()[(idx + 1) % 2]), base(A.num_vertices()[idx] + 1) {
       fill_biadjacency<idx>(A, *this, sort_biadjacency, policy);
     }
   
     template <class ExecutionPolicy = std::execution::parallel_unsequenced_policy>
     index_biadjacency(index_edge_list<vertex_id_type, bipartite_graph_base, directedness::undirected, Attributes...>& A,
                       bool sort_biadjacency = false, ExecutionPolicy&& policy = {})
       requires(std::is_same<bipartite_graph_base, bipartite_graph_base>::value)
         : bipartite_graph_base(A.num_vertices()[idx], A.num_vertices()[(idx + 1) % 2]), base(A.num_vertices()[idx] + 1) {
       fill_biadjacency<idx>(A, *this, sort_biadjacency, policy);
     }
     // customized move constructor
     index_biadjacency(size_t N1, std::vector<vertex_id>&& indices, std::vector<vertex_id>&& first_to_be, std::vector<Attributes>&&... rest_to_be)
       requires(std::is_same<bipartite_graph_base, bipartite_graph_base>::value)
         : bipartite_graph_base(indices.size() - 1, N1), base(std::move(indices), std::move(first_to_be), std::move(rest_to_be)...) {
     }
     index_biadjacency(size_t N1, std::vector<vertex_id>&& indices, std::tuple<std::vector<vertex_id>, std::vector<Attributes>...>&& to_be_indexed)
         : bipartite_graph_base(indices.size() - 1, N1), base(std::move(indices), std::move(to_be_indexed)) {
     }
     // customized copy constructor
     index_biadjacency(size_t N1, const std::vector<vertex_id>& indices, const std::vector<vertex_id>& first_to_be,
                       const std::vector<Attributes>&... rest_to_be)
       requires(std::is_same<bipartite_graph_base, bipartite_graph_base>::value)
         : bipartite_graph_base(indices.size() - 1, N1), base(indices, first_to_be, rest_to_be...) {
     }
     index_biadjacency(size_t N1, const std::vector<vertex_id>& indices,
                       const std::tuple<std::vector<vertex_id>, std::vector<Attributes>...>& to_be_indexed)
       requires(std::is_same<bipartite_graph_base, bipartite_graph_base>::value)
         : bipartite_graph_base(indices.size() - 1, N1), base(indices, to_be_indexed) {
     }
   
     auto num_vertices() const {
       return vertex_cardinality;
     }
     num_edges_type num_edges() const {
       return base::to_be_indexed_.size();
     };
     void serialize(const std::string& outfile_name) {
       std::ofstream out_file(outfile_name, std::ofstream::binary);
       bipartite_graph_base::serialize(out_file);
       base::serialize(out_file);
     }
   
     void deserialize(const std::string& infile_name) {
       std::ifstream infile(infile_name, std::ifstream::binary);
       bipartite_graph_base::deserialize(infile);
       base::deserialize(infile);
     }
   };
   
   template <int idx, typename... Attributes>
   using biadjacency = index_biadjacency<idx, default_index_t, default_vertex_id_type, Attributes...>;
   
   template <int idx, edge_list_graph edge_list_t>
   auto make_biadjacency(edge_list_t& el) {
     return biadjacency<idx>(el);
   }
   
   
   template <int idx, edge_list_c edge_list_t, std::unsigned_integral u_integral,
             class ExecutionPolicy = std::execution::parallel_unsequenced_policy>
   auto make_biadjacency(edge_list_t& el, u_integral n0, u_integral n1, directedness edge_directedness = directedness::directed,
                         ExecutionPolicy&& policy = {}) {
     biadjacency<idx> adj(n0, n1);
     fill_biadjacency<idx>(el, adj, policy);
     return adj;
   }
   
   
   //template <int idx, std::unsigned_integral index_type, std::unsigned_integral vertex_id_type, typename... Attributes>
   //auto num_vertices(const index_adjacency<idx, index_type, vertex_id_type, Attributes...>& g) {
   //  return g.num_vertices();
   //}
   //index_adjacency num_vertices CPO
   template <int idx, std::unsigned_integral index_type, std::unsigned_integral vertex_id_type, typename... Attributes>
   auto tag_invoke(const num_vertices_tag, const index_adjacency<idx, index_type, vertex_id_type, Attributes...>& g) {
     return g.num_vertices()[0];
   }
   //index_adjacency degree CPO
   template <int idx, std::unsigned_integral index_type, std::unsigned_integral vertex_id_type, std::unsigned_integral lookup_type,
             typename... Attributes>
   auto tag_invoke(const degree_tag, const index_adjacency<idx, index_type, vertex_id_type, Attributes...>& g, lookup_type i) {
     return g[i].size();
   }
   //index_adjacency degree CPO
   template <int idx, std::unsigned_integral index_type, std::unsigned_integral vertex_id_type, typename... Attributes>
   auto tag_invoke(const degree_tag, const index_adjacency<idx, index_type, vertex_id_type, Attributes...>& g,
                   const typename index_adjacency<idx, index_type, vertex_id_type, Attributes...>::sub_view& v) {
     return v.size();
   }
   //index_biadjacency num_vertices CPO
   template <int idx, std::unsigned_integral index_type, std::unsigned_integral vertex_id_type, typename... Attributes>
   auto tag_invoke(const num_vertices_tag, const index_biadjacency<idx, index_type, vertex_id_type, Attributes...>& g, int jdx = 0) {
     return g.num_vertices()[jdx];
   }
   //index_biadjacency degree CPO
   template <int idx, std::unsigned_integral index_type, std::unsigned_integral vertex_id_type, std::unsigned_integral lookup_type,
             typename... Attributes>
   auto tag_invoke(const degree_tag, const index_biadjacency<idx, index_type, vertex_id_type, Attributes...>& g, lookup_type i) {
     return g[i].size();
   }
   //index_biadjacency degree CPO
   template <int idx, std::unsigned_integral index_type, std::unsigned_integral vertex_id_type, typename... Attributes>
   auto tag_invoke(const degree_tag, const index_biadjacency<idx, index_type, vertex_id_type, Attributes...>& g,
                   const typename index_biadjacency<idx, index_type, vertex_id_type, Attributes...>::sub_view& v) {
     return v.size();
   }
   //degree CPO
   template <class Iterator>
   auto tag_invoke(const degree_tag, const splittable_range_adaptor<Iterator>& n) {
     return n.size();
   }
   
   }    // namespace graph
   }    // namespace nw
   
   #endif    // NW_GRAPH_ADJACENCY_HPP
