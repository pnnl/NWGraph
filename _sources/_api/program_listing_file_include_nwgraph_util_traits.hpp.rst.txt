
.. _program_listing_file_include_nwgraph_util_traits.hpp:

Program Listing for File traits.hpp
===================================

|exhale_lsh| :ref:`Return to documentation for file <file_include_nwgraph_util_traits.hpp>` (``include/nwgraph/util/traits.hpp``)

.. |exhale_lsh| unicode:: U+021B0 .. UPWARDS ARROW WITH TIP LEFTWARDS

.. code-block:: cpp

   
   #ifndef NW_GRAPH_TRAITS_HPP
   #define NW_GRAPH_TRAITS_HPP
   
   #include <atomic>
   #include <iterator>
   #include <tbb/blocked_range.h>
   #include <tuple>
   
   namespace nw {
   namespace graph {
   
   template <class>
   inline constexpr bool is_atomic_v = false;
   template <class T>
   inline constexpr bool is_atomic_v<std::atomic<T>> = true;
   template <class T>
   inline constexpr bool is_atomic_v<std::atomic_ref<T>> = true;
   
   template <class T>
   struct remove_atomic {
     using type = T;
   };
   template <class T>
   struct remove_atomic<std::atomic<T>> {
     using type = T;
   };
   template <class T>
   struct remove_atomic<std::atomic_ref<T>> {
     using type = T;
   };
   template <class T>
   using remove_atomic_t = typename remove_atomic<T>::type;
   
   template <class>
   inline constexpr bool is_tbb_range_v = false;
   template <class T>
   inline constexpr bool is_tbb_range_v<tbb::blocked_range<T>> = true;
   
   template <class>
   inline constexpr bool is_tuple_v = false;
   template <class... Ts>
   inline constexpr bool is_tuple_v<std::tuple<Ts...>> = true;
   
   template <class, class = void>
   struct is_iterator : std::false_type {};
   template <class T>
   struct is_iterator<T*, void> : std::true_type {};
   template <class T>
   struct is_iterator<const T*, void> : std::true_type {};
   template <class T>
   struct is_iterator<T, std::enable_if_t<!std::is_same_v<typename std::iterator_traits<T>::value_type, void>>> : std::true_type {};
   
   template <class T>
   inline constexpr bool is_iterator_v = is_iterator<T>::value;
   
   template <class Iter>
   using select_access_type =
       std::conditional_t<(std::is_same_v<Iter, std::vector<bool>::iterator> || std::is_same_v<Iter, std::vector<bool>::const_iterator>),
                          typename std::iterator_traits<Iter>::value_type, typename std::iterator_traits<Iter>::reference>;
   
   template <class Range>
   using select_range_access_type =
       std::conditional_t<(std::is_same_v<Range, std::vector<bool>> || std::is_same_v<Range, const std::vector<bool>>),
                          std::ranges::range_value_t<Range>, std::ranges::range_reference_t<Range>>;
   
   
   }    // namespace graph
   }    // namespace nw
   
   #endif    // NW_GRAPH_TRAITS_HPP
