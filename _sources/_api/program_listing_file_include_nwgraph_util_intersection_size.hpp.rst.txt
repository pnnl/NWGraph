
.. _program_listing_file_include_nwgraph_util_intersection_size.hpp:

Program Listing for File intersection_size.hpp
==============================================

|exhale_lsh| :ref:`Return to documentation for file <file_include_nwgraph_util_intersection_size.hpp>` (``include/nwgraph/util/intersection_size.hpp``)

.. |exhale_lsh| unicode:: U+021B0 .. UPWARDS ARROW WITH TIP LEFTWARDS

.. code-block:: cpp

   
   #ifndef NW_GRAPH_INTERSECTION_SIZE_HPP
   #define NW_GRAPH_INTERSECTION_SIZE_HPP
   
   #if defined(CL_SYCL_LANGUAGE_VERSION)
   #include <dpstd/algorithm>
   #include <dpstd/execution>
   #include <dpstd/numeric>
   #else
   #include <algorithm>
   #include <execution>
   #include <numeric>
   #endif
   #include <type_traits>
   
   namespace nw {
   namespace graph {
   template <class A, class B, class C, class D, class ExecutionPolicy>
   std::size_t intersection_size(A i, B&& ie, C j, D&& je, ExecutionPolicy&& ep) {
     // Custom comparator because we know our iterator operator* produces tuples
     // and we only care about the first value.
     static constexpr auto lt = [](auto&& x, auto&& y) { return std::get<0>(x) < std::get<0>(y); };
   
     // Use our own trivial loop for the intersection size when the execution
     // policy is sequential, otherwise rely on std::set_intersection.
     //
     // @todo We really don't need set intersection. You'd hope that it would be
     //       efficient with the output counter, but it just isn't. Parallelizing
     //       the intersection size seems non-trivial though.
     if constexpr (std::is_same_v<std::decay_t<ExecutionPolicy>, std::execution::sequenced_policy>) {
       std::size_t n = 0;
       while (i != ie && j != je) {
         if (lt(*i, *j)) {
           ++i;
         } else if (lt(*j, *i)) {
           ++j;
         } else {
           ++n;
           ++i;
           ++j;
         }
       }
       return n;
       (void)ep;
     } else {
       return std::set_intersection(std::forward<ExecutionPolicy>(ep), std::forward<A>(i), std::forward<B>(ie), std::forward<C>(j),
                                    std::forward<D>(je), nw::graph::counter {}, lt);
     }
   }
   
   template <class R, class S, class ExecutionPolicy,
             std::enable_if_t<std::is_execution_policy_v<std::decay_t<ExecutionPolicy>>, void**> = nullptr>
   std::size_t intersection_size(R&& i, S&& j, ExecutionPolicy&& ep) {
     return intersection_size(i.begin(), i.end(), j.begin(), j.end(), std::forward<ExecutionPolicy>(ep));
   }
   
   template <class A, class B, class Range, class ExecutionPolicy,
             std::enable_if_t<std::is_execution_policy_v<std::decay_t<ExecutionPolicy>>, void**> = nullptr>
   std::size_t intersection_size(A&& i, B&& ie, Range&& j, ExecutionPolicy&& ep) {
     return intersection_size(std::forward<A>(i), std::forward<B>(ie), j.begin(), j.end(), std::forward<ExecutionPolicy>(ep));
   }
   
   template <class A, class B, class C, class D, std::enable_if_t<!std::is_execution_policy_v<std::decay_t<D>>, void**> = nullptr>
   std::size_t intersection_size(A&& i, B&& ie, C&& j, D&& je) {
     return intersection_size(std::forward<A>(i), std::forward<B>(ie), std::forward<C>(j), std::forward<D>(je), std::execution::seq);
   }
   
   template <class R, class S>
   std::size_t intersection_size(R&& i, S&& j) {
     return intersection_size(i.begin(), i.end(), j.begin(), j.end(), std::execution::seq);
   }
   
   template <class A, class B, class Range, std::enable_if_t<!std::is_execution_policy_v<std::decay_t<Range>>, void**> = nullptr>
   std::size_t intersection_size(A&& i, B&& ie, Range&& j) {
     return intersection_size(std::forward<A>(i), std::forward<B>(ie), j.begin(), j.end(), std::execution::seq);
   }
   }    // namespace graph
   }    // namespace nw
   
   #endif    // NW_GRAPH_INTERSECTION_SIZE_HPP
