
.. _program_listing_file_include_nwgraph_graph_adaptor.hpp:

Program Listing for File graph_adaptor.hpp
==========================================

|exhale_lsh| :ref:`Return to documentation for file <file_include_nwgraph_graph_adaptor.hpp>` (``include/nwgraph/graph_adaptor.hpp``)

.. |exhale_lsh| unicode:: U+021B0 .. UPWARDS ARROW WITH TIP LEFTWARDS

.. code-block:: cpp

   #include <nwgraph/vovos.hpp>
   #include <vector>
   #include <string>
   
   // Build a graph from vertex labels and edge data
   std::vector<std::string> vertices = {"A", "B", "C", "D"};
   std::vector<std::tuple<std::string, std::string>> edges = {
       {"A", "B"}, {"A", "C"}, {"B", "D"}, {"C", "D"}
   };
   
   // Create plain graph (no edge properties) from labeled data
   auto graph = nw::graph::make_plain_graph<nw::graph::vov<>>(vertices, edges);
   
   // Or with edge weights
   std::vector<std::tuple<std::string, std::string, double>> weighted_edges = {
       {"A", "B", 1.5}, {"A", "C", 2.0}, {"B", "D", 1.0}
   };
   auto wgraph = nw::graph::make_property_graph<nw::graph::vov<double>>(
       vertices, weighted_edges);
   
   // Use graph_adaptor for dynamic edge insertion
   nw::graph::graph_adaptor<nw::graph::vov<>> dyn_graph(4);
   dyn_graph.open_for_push_back();
   dyn_graph.push_back(0, 1);  // Add edge 0 -> 1
   dyn_graph.push_back(0, 2);  // Add edge 0 -> 2
   dyn_graph.close_for_push_back();
   
   #include "nwgraph/graph_base.hpp"
   #include "nwgraph/graph_concepts.hpp"
   
   #ifndef NW_GRAPH_GRAPH_ADAPTOR_HPP
   #define NW_GRAPH_GRAPH_ADAPTOR_HPP
   
   namespace nw::graph {
   
   
   namespace has {
   
   template <class U>
   class has_push_back {
   
     template <class W>
       requires(requires(W v, typename W::value_type t) { v.push_back(t); } == true)
     static constexpr bool test() {
       return true;
     }
   
   
     template <class W>
       requires(requires(W v, typename W::value_type t) { v.push_back(t); } == false)
     static constexpr bool test() {
       return false;
     }
   
   public:
     static constexpr bool value = test<U>();
   };
   
   
   template <template <class> class W, class U>
   class has_push_front {
   
     template <template <class> class V, class T>
       requires(requires(V<T> v, T t) { v.push_front(t); } == true)
     static constexpr bool test() {
       return true;
     }
   
   
     template <template <class> class V, class T>
       requires(requires(V<T> v, T t) { v.push_front(t); } == false)
     static constexpr bool test() {
       return false;
     }
   
   public:
     static constexpr bool value = test<W, U>();
   };
   
   }    // namespace has
   
   
   template <class V>
   bool has_push_back_v = has::has_push_back<V>::value;
   
   template <template <class> class V, class T>
   bool has_push_front_v = has::has_push_front<V, T>::value;
   
   
   template <class T>
     requires(min_idx_adjacency_list<T> || idx_adjacency_list<T>)
   class graph_adaptor : public unipartite_graph_base, public T {
   
     using base       = T;
     using graph_base = unipartite_graph_base;
   
     size_t num_edges_ { 0 };
   
   public:
     explicit graph_adaptor(size_t N = 0) : base(N) {
     }
   
     void open_for_push_back() {
       graph_base::is_open = true;
     }
   
     void close_for_push_back() {
       graph_base::is_open = true;
     }
   
     template <class... Attributes>
     void push_back(size_t i, Attributes... attrs) {
       if (i >= base::size()) {
         for (size_t j = base::size(); j <= i; ++j) {
           base::emplace_back();
         }
       }
       base::operator[](i).emplace_back(attrs...);
     }
   
     template <class... Attributes>
     void push_front(size_t i, Attributes... attrs) {
       if (i >= base::size()) {
         for (size_t j = base::size(); j <= i; ++j) {
           base::emplace_back();
         }
       }
       base::operator[](i).emplace_back(attrs...);
     }
   
     auto size() const {
       return base::size();
     }
   
     auto num_vertices() const {
       return base::size();
     }
   
     auto num_edgees() const {
       return num_edges_;
     }
   };
   
   
   template <typename... Ts>
   auto graph_edge(std::tuple<Ts...> t) {
     return nth_cdr<1>(t);
   }
   
   template <class EdgeList, class Adjacency>
   void push_back_plain_fill(const EdgeList& edge_list, Adjacency& adj, bool directed, size_t idx) {
     const size_t jdx = (idx + 1) % 2;
   
     for (auto&& e : edge_list) {
   
       if (idx == 0) {
         std::apply([&](size_t u, size_t v) { adj[u].emplace_back(v); }, e);
         if (!directed) {
           std::apply([&](size_t u, size_t v) { adj[v].emplace_back(u); }, e);
         }
       } else {
         std::apply([&](size_t u, size_t v) { adj[v].emplace_back(u); }, e);
         if (!directed) {
           std::apply([&](size_t u, size_t v) { adj[u].emplace_back(v); }, e);
         }
       }
     }
   }
   
   template <class EdgeList, class Adjacency>
   void push_back_fill(const EdgeList& edge_list, Adjacency& adj, bool directed, size_t idx) {
     const size_t jdx = (idx + 1) % 2;
   
     for (auto&& e : edge_list) {
   
       if (idx == 0) {
         std::apply([&](size_t u, size_t v, auto... props) { adj[u].emplace_back(v, props...); }, e);
         if (!directed) {
           std::apply([&](size_t u, size_t v, auto... props) { adj[v].emplace_back(u, props...); }, e);
         }
       } else {
         std::apply([&](size_t u, size_t v, auto... props) { adj[v].emplace_back(u, props...); }, e);
         if (!directed) {
           std::apply([&](size_t u, size_t v, auto... props) { adj[u].emplace_back(v, props...); }, e);
         }
       }
     }
   }
   
   
   template <edge_list_graph EdgeList, class M, std::ranges::random_access_range E>
   auto make_plain_edges(M& map, const E& edges) {
     EdgeList index_edges;
   
     for (auto&& e : edges) {
       std::apply([&](auto&& u, auto&& v, auto... props_) { index_edges.push_back(std::make_tuple(map[u], map[v])); }, e);
     }
   
     return index_edges;
   }
   
   template <edge_list_graph EdgeList, class M, std::ranges::random_access_range E>
   auto make_property_edges(M& map, const E& edges) {
     EdgeList index_edges;
   
     for (auto&& e : edges) {
       std::apply([&](auto&& u, auto&& v, auto... props_) { index_edges.push_back(std::make_tuple(map[u], map[v], props_...)); }, e);
     }
   
     return index_edges;
   }
   
   
   template <adjacency_list_graph Graph, std::ranges::random_access_range V, std::ranges::random_access_range E>
   auto make_plain_graph(const V& vertices, const E& edges, bool directed = true, size_t idx = 0) {
     auto vertex_map  = make_index_map(vertices);
     auto index_edges = make_plain_edges(vertex_map, edges);
   
     Graph G(size(vertices));
     push_back_plain_fill(index_edges, G, directed, idx);
   
     return G;
   }
   
   template <adjacency_list_graph Graph, std::ranges::random_access_range V, std::ranges::random_access_range E>
   auto make_index_graph(const V& vertices, const E& edges, bool directed = true, size_t idx = 0) {
   
     auto vertex_map  = make_index_map(vertices);
     auto index_edges = make_index_edges(vertex_map, edges);
   
     Graph G(size(vertices));
   
     push_back_fill(index_edges, G, directed, idx);
   
     return G;
   }
   
   template <adjacency_list_graph Graph, std::ranges::random_access_range V, std::ranges::forward_range E>
   auto make_property_graph(const V& vertices, const E& edges, bool directed = true, size_t idx = 0) {
   
     auto vertex_map     = make_index_map(vertices);
     auto property_edges = make_property_edges(vertex_map, edges);
   
     Graph G(size(vertices));
   
     push_back_fill(property_edges, G, directed, idx);
   
     return G;
   }
   
   template <adjacency_list_graph Graph, std::ranges::random_access_range V1, std::ranges::random_access_range V2,
             std::ranges::random_access_range E>
   auto make_plain_bipartite_graph(const V1& left_vertices, const V2& right_vertices, const E& edges, size_t idx = 0) {
   
     auto index_edges = data_to_graph_edge_list(left_vertices, right_vertices, edges);
     auto graph_size  = idx == 0 ? size(left_vertices) : size(right_vertices);
   
     Graph G(size(left_vertices));
     push_back_plain_fill(index_edges, G, true, idx);
   
     return G;
   }
   
   template <adjacency_list_graph Graph, std::ranges::random_access_range V, std::ranges::random_access_range E>
   auto make_bipartite_graphs(const V& left_vertices, const V& right_vertices, const E& edges) {
   
     auto index_edges = data_to_graph_edge_list<>(left_vertices, right_vertices, edges);
   
     Graph G(size(left_vertices));
     Graph H(size(right_vertices));
   
     push_back_fill(index_edges, G, true, 0);
     push_back_fill(index_edges, H, true, 1);
   
     return make_tuple(G, H);
   }
   
   
   }    // namespace nw::graph
   
   
   #endif    // NW_GRAPH_GRAPH_ADAPTOR_HPP
