
.. _program_listing_file_include_nwgraph_util_AtomicBitVector.hpp:

Program Listing for File AtomicBitVector.hpp
============================================

|exhale_lsh| :ref:`Return to documentation for file <file_include_nwgraph_util_AtomicBitVector.hpp>` (``include/nwgraph/util/AtomicBitVector.hpp``)

.. |exhale_lsh| unicode:: U+021B0 .. UPWARDS ARROW WITH TIP LEFTWARDS

.. code-block:: cpp

   
   // Create a visited array for 1000 vertices
   nw::graph::AtomicBitVector<> visited(1000);
   
   // Thread-safe check-and-set pattern for BFS
   size_t vertex = 42;
   if (!visited.atomic_set(vertex)) {
       // First thread to mark this vertex - process it
       process_vertex(vertex);
   }
   
   // Check if a vertex was visited (relaxed ordering for read-only)
   if (visited.get(vertex)) {
       // Already visited
   }
   
   // Iterate over all set bits (non-zero vertices)
   for (auto v : visited) {
       std::cout << "Visited: " << v << std::endl;
   }
   
   // Clear all bits for reuse
   visited.clear();
   
   #ifndef NW_GRAPH_ATOMIC_BIT_VECTOR_HPP
   #define NW_GRAPH_ATOMIC_BIT_VECTOR_HPP
   
   #include "nwgraph/util/atomic.hpp"
   #if defined(CL_SYCL_LANGUAGE_VERSION)
   #include <dpstd/algorithm>
   #include <dpstd/execution>
   #else
   #include <algorithm>
   #include <execution>
   #endif
   #include <cstddef>
   #include <cstdint>
   #include <memory>
   #include <tuple>
   
   namespace nw {
   namespace graph {
   template <class Word = std::uint64_t>
   class AtomicBitVector {
     static constexpr int BITS = sizeof(Word) * 8;
   
     std::size_t bits_;
     Word*       data_;
   
   public:
     AtomicBitVector(std::size_t bits, bool init = true) : bits_(bits), data_(new Word[words(bits)]) {
       if (init) clear();
     }
   
     ~AtomicBitVector() {
       delete[] data_;
     }
   
     AtomicBitVector(AtomicBitVector&& rhs) : bits_(std::exchange(rhs.bits_, 0)), data_(std::exchange(rhs.data_, nullptr)) {
     }
   
     AtomicBitVector& operator=(AtomicBitVector&& rhs) {
       bits_ = std::exchange(rhs.bits_, 0);
       data_ = std::exchange(rhs.data_, nullptr);
       return *this;
     }
   
     void clear() {
       std::fill(std::execution::par_unseq, data_, data_ + words(bits_), Word(0));
     }
   
     template <std::memory_order order = std::memory_order_relaxed>
     Word get(std::size_t i) const {
       auto&& [word, mask] = split(i);
       return nw::graph::load<order>(data_[word]) & mask;
     }
   
     template <std::memory_order order = std::memory_order_relaxed>
     Word set(std::size_t i) {
       auto&& [word, mask] = split(i);
       return nw::graph::fetch_or<order>(data_[word], mask) & mask;
     }
   
     Word atomic_get(std::size_t i) const {
       return get<std::memory_order_acquire>(i);
     }
   
     Word atomic_set(std::size_t i) {
       return set<std::memory_order_acq_rel>(i);
     }
   
     class non_zero_iterator {
       Word*       data_;       
       std::size_t n_;          
       std::size_t word_;       
       std::size_t bit_ = 0;    
   
     public:
       using value_type        = std::size_t;
       using difference_type   = std::ptrdiff_t;
       using reference         = const std::size_t;    // need something better
       using pointer           = void;
       using iterator_category = std::input_iterator_tag;
   
       non_zero_iterator(Word* data, std::size_t n, std::size_t word) : data_(data), n_(n), word_(word) {
         search_next();
       }
   
       reference operator*() {
         return word_ * BITS + bit_;
       }
   
       // auto operator->() {
       //   // what should this do?
       // }
   
       non_zero_iterator& operator++() {
         // if there is possibly another non-zero in the current word then use it
         if (word_ < n_ && ++bit_ < BITS) {
           if (Word w = data_[word_] >> bit_) {
             bit_ += __builtin_ctzl(w);
             return *this;
           }
         }
   
         // otherwise we're on a slow path because we have to search for the next
         // non-zero word
         ++word_;
         return search_next();
       }
   
       non_zero_iterator operator++(int) {
         non_zero_iterator i(*this);
         ++(*this);
         return i;
       }
   
       bool operator!=(const non_zero_iterator& b) const {
         return (word_ != b.word_ || bit_ != b.bit_ || data_ != b.data_);
       }
   
       bool operator==(const non_zero_iterator& b) const {
         return !operator!=(b);
       }
   
     private:
       non_zero_iterator& search_next() {
         // search for the next non-zero word, starting with word_
         for (; word_ < n_; ++word_) {
           if (Word w = data_[word_]) {
             bit_ = __builtin_ctzl(w);
             return *this;
           }
         }
   
         // saturate for comparisons with end()
         bit_  = 0;
         word_ = n_;
         return *this;
       }
     };
   
     non_zero_iterator begin() {
       return { data_, words(bits_), 0 };
     }
     non_zero_iterator end() {
       return { data_, words(bits_), words(bits_) };
     }
   
     // Our non_zero_iterators are basically input iterators and thus can't be
     // split using the splittable range adapter, which only handles random-access
     // ranges at the moment. This custom range can be split on word boundaries.
     class non_zero_range {
       Word*       data_;
       std::size_t n_;
       std::size_t begin_;
       std::size_t end_;
       std::size_t cutoff_;
   
     public:
       non_zero_range(Word* data, std::size_t n, std::size_t begin, std::size_t end, std::size_t cutoff)
           : data_(data), n_(n), begin_(begin), end_(end), cutoff_(cutoff) {
       }
   
       non_zero_range(const non_zero_range&) = default;
       non_zero_range(non_zero_range&&)      = default;
   
       non_zero_range(non_zero_range& a, tbb::split)
           : data_(a.data_), n_(a.n_), begin_(a.begin_), end_(a.begin_ += a.size() / 2), cutoff_(a.cutoff_) {
       }
   
       non_zero_iterator begin() {
         return { data_, n_, begin_ };
       }
       non_zero_iterator end() {
         return { data_, n_, end_ };
       }
   
       std::size_t size() const {
         return end_ - begin_;
       }
       bool empty() const {
         return size() == 0;
       }
       bool is_divisible() const {
         return size() > cutoff_;
       }
     };
   
     non_zero_range non_zeros(std::size_t cutoff) {
       return { data_, words(bits_), 0, words(bits_), cutoff };
     }
   
   private:
     static constexpr std::tuple<std::size_t, Word> split(std::size_t i) {
       std::size_t word   = i / BITS;
       std::size_t offset = i % BITS;
       Word        mask   = Word(1) << offset;
       return { word, mask };
     }
   
     static constexpr std::size_t words(std::size_t n) {
       return n / BITS + ((n % BITS) ? 1 : 0);
     }
   };
   }    // namespace graph
   }    // namespace nw
   
   #endif    // NW_GRAPH_ATOMIC_BIT_VECTOR_HPP
