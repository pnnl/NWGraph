

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../">
<head>
  <meta charset="utf-8" /><meta name="viewport" content="width=device-width, initial-scale=1" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Graph Background &mdash; NW Graph 0.10.15 documentation</title>
      <link rel="stylesheet" type="text/css" href="../_static/pygments.css?v=649a27d8" />
      <link rel="stylesheet" type="text/css" href="../_static/css/theme.css?v=9edc463e" />
      <link rel="stylesheet" type="text/css" href="../_static/graphviz.css?v=4ae1632d" />
      <link rel="stylesheet" type="text/css" href="../_static/collapsible-lists/css/tree_view.css?v=a885cde7" />
      <link rel="stylesheet" type="text/css" href="../_static/css/custom.css?v=afbbf639" />

  
      <script src="../_static/jquery.js?v=5d32c60e"></script>
      <script src="../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="../_static/documentation_options.js?v=a8af70a8"></script>
      <script src="../_static/doctools.js?v=fd6eb6e6"></script>
      <script src="../_static/sphinx_highlight.js?v=6ffebe34"></script>
      <script src="../_static/collapsible-lists/js/CollapsibleLists.compressed.js?v=73120307"></script>
      <script src="../_static/collapsible-lists/js/apply-collapsible-lists.js?v=660e4f45"></script>
      <script>window.MathJax = {"TeX": {"Macros": {"RR": "{\\mathbb R}", "Real": "{\\mathbb R}", "Complex": "{\\mathbb C}", "mat": ["{\\mathbf{#1}}", 1], "vec": ["{\\mathbf{#1}}", 1], "bold": ["{\\bf #1}", 1], "Spc": ["\\mathbb{#1}", 1], "norm": ["|| #1 ||", 1]}}}</script>
      <script defer="defer" src="https://cdn.jsdelivr.net/npm/mathjax@4/tex-mml-chtml.js"></script>
    <script src="../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Generic Programming in C++20" href="generic-programming.html" />
    <link rel="prev" title="NWGraph: The Northwest Graph Library" href="introduction.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../index.html" class="icon icon-home">
            NW Graph
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="getting_started.html">Quickstart</a></li>
<li class="toctree-l1"><a class="reference internal" href="benchmarking.html">Benchmarking with NWGraph</a></li>
<li class="toctree-l1"><a class="reference internal" href="introduction.html">NWGraph: The Northwest Graph Library</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Graph Background</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#graph-terminology">Graph Terminology</a></li>
<li class="toctree-l2"><a class="reference internal" href="#graph-models">Graph Models</a></li>
<li class="toctree-l2"><a class="reference internal" href="#representing-graphs">Representing Graphs</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="generic-programming.html">Generic Programming in C++20</a></li>
<li class="toctree-l1"><a class="reference internal" href="graph-concepts.html">Generic Graph Algorithms</a></li>
<li class="toctree-l1"><a class="reference internal" href="algorithms.html">NWGraph Algorithms</a></li>
<li class="toctree-l1"><a class="reference internal" href="adaptors.html">Graph Range Adaptors</a></li>
<li class="toctree-l1"><a class="reference internal" href="data-structures.html">Model Data Structures</a></li>
<li class="toctree-l1"><a class="reference internal" href="performance.html">Performance Evaluation</a></li>
<li class="toctree-l1"><a class="reference internal" href="related.html">Related Libraries and Toolkits</a></li>
<li class="toctree-l1"><a class="reference internal" href="references.html">References Cited</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../examples/index.html">Examples</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../nwgraph_api.html">NWGraph API Reference</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">NW Graph</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../index.html" class="icon icon-home" aria-label="Home"></a></li>
      <li class="breadcrumb-item active">Graph Background</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../_sources/userguide/graph-background-ii.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="graph-background">
<span id="sec-graph-background"></span><h1>Graph Background<a class="headerlink" href="#graph-background" title="Link to this heading"></a></h1>
<p>In order to describe the NWGraph library and its abstractions and
interfaces, it is important to be precise about what we mean when we say
“graph,” not only in terms of the mathematical abstraction, but also in
terms of the corresponding software abstractions. To define our
terminology and to amplify our point regarding “graphs are not for
storing data,” we walk through the steps involved in representing the
implicit relationships in data tables as a graph.</p>
<p><strong>Remark.</strong> Understanding graphs is necessary to develop requirements
for algorithms. However, it should be noted that we don’t derive those
requirements from the graph model, but instead from the algorithms. This
is a key distinction between generic programming and, say, OO
requirements analysis.</p>
<section id="graph-terminology">
<span id="sec-graph-terminology"></span><h2>Graph Terminology<a class="headerlink" href="#graph-terminology" title="Link to this heading"></a></h2>
<p>Abstractly, we define a <em>graph</em> <span class="math notranslate nohighlight">\(G\)</span> as comprising two finite sets,
<span class="math notranslate nohighlight">\(G =\{ V, E \}\)</span>, where the set <span class="math notranslate nohighlight">\(V\)</span> is a set of entities of
interest, “vertices” or “nodes,” and <span class="math notranslate nohighlight">\(E\)</span> is a set of pairs of
entities from <span class="math notranslate nohighlight">\(V\)</span>, “edges” or “links.” Without loss of generality
we label the entities in <span class="math notranslate nohighlight">\(V\)</span> as <span class="math notranslate nohighlight">\(v_i\)</span> so that
<span class="math notranslate nohighlight">\(V = \{ v_0, v_1, \ldots v_{n-1} \}\)</span>. The set of edges, also
labeled, can be constructed using the labeled entities from <span class="math notranslate nohighlight">\(V\)</span> so
that <span class="math notranslate nohighlight">\(E = \{ e_0, e_1, \ldots e_{m-1} \}\)</span>. The edges may be
ordered pairs, denoted as <span class="math notranslate nohighlight">\((v_i, v_j)\)</span>, which have equality
defined such that
<span class="math notranslate nohighlight">\((v_i,v_j) = (v_m,v_n) \leftrightarrow v_i = v_m  \wedge v_j = v_n\)</span>.
Or, the edges may be unordered sets, denoted as <span class="math notranslate nohighlight">\(\{v_i, v_j\}\)</span>
which have equality defined as
<span class="math notranslate nohighlight">\((v_i,v_j) = (v_m,v_n) \leftrightarrow\left( v_i = v_m  \wedge v_j = v_n\right) \vee \left( v_i = v_n  \wedge v_j = v_m\right)\)</span>.
If a graph is defined with ordered edges we say the graph is <em>directed</em>;
if the graph is defined with unordered edges we say the graph is
<em>undirected</em>.</p>
</section>
<section id="graph-models">
<h2>Graph Models<a class="headerlink" href="#graph-models" title="Link to this heading"></a></h2>
<p>Graphs are powerful abstractions because they allow us to reason about
the relationships between entities, irrespective of what the entities
actually are. But, when we use graph algorithms in practice, we are
using them to model some specific problem. Since one of the motivations
behind NWGraph is to support graph computing in the context of real
programs, we briefly describe the first part of the abstraction process
when modeling with graphs.</p>
<figure class="align-center" id="fig-graph-model-circuit">
<a class="reference internal image-reference" href="../_images/circuit_graph.pdf"><img alt="Electrical circuit modeled as a directed graph. The nodes in the circuit are modeled as vertices and the circuit elements are modeled as edges." src="../_images/circuit_graph.pdf" style="width: 90%;" />
</a>
<figcaption>
<p><span class="caption-number">Fig. 1 </span><span class="caption-text">Electrical circuit modeled as a directed graph. The nodes in the
circuit are modeled as vertices and the circuit elements are modeled
as edges.</span><a class="headerlink" href="#fig-graph-model-circuit" title="Link to this image"></a></p>
</figcaption>
</figure>
<figure class="align-center" id="fig-graph-model-airports">
<a class="reference internal image-reference" href="../_images/airport_graph.pdf"><img alt="Airport route table modeled as an undirected graph. Airports are modeled as vertices and routes between cities are modeled as (weighted) edges." src="../_images/airport_graph.pdf" style="width: 90%;" />
</a>
<figcaption>
<p><span class="caption-number">Fig. 2 </span><span class="caption-text">Airport route table modeled as an undirected graph. Airports are
modeled as vertices and routes between cities are modeled as
(weighted) edges.</span><a class="headerlink" href="#fig-graph-model-airports" title="Link to this image"></a></p>
</figcaption>
</figure>
<p><a class="reference internal" href="#fig-graph-model-circuit"><span class="std std-numref">Fig. 1</span></a>
shows a model of an electrical
circuit as a directed graph, both schematically, as a circle and line
diagram, and mathematically, as the sets <span class="math notranslate nohighlight">\(V\)</span> and <span class="math notranslate nohighlight">\(E\)</span>.
Two-terminal circuit elements connect to each other at given circuit
nodes. We thus model circuit connection points as graph vertices, and
the connections between them as edges. In the case of circuits,
orientation of circuit elements matters and so we use directed edges in
the graph.</p>
<p><a class="reference internal" href="#fig-graph-model-airports"><span class="std std-numref">Fig. 2</span></a>
similarly shows a model of an
airport route table as an undirected graph. We begin with a table of
airports and a table of distances in kilometers between pairs of
airports. We model this situation as a graph by identifying graph nodes
with airports and graph edges with pairs of cities that are given as
pairs in the distance table.</p>
</section>
<section id="representing-graphs">
<span id="sec-representing-graphs"></span><h2>Representing Graphs<a class="headerlink" href="#representing-graphs" title="Link to this heading"></a></h2>
<p>To define algorithms on graphs and to be able to reason about those
algorithms, we need to define some representations for graphs (and
corresponding terminology)—–not much can be done computationally with
abstract sets of vertices and edges. Various characteristics of these
representations are what we use to express algorithms (still abstractly)
but when those algorithms are implemented as generic library functions,
those characteristics will in turn become the basis for the library’s
concepts.</p>
<figure class="align-center" id="fig-circuit-index-to-adj">
<a class="reference internal image-reference" href="../_images/circuit_index_graph_with_vit.pdf"><img alt="Circuit index graph." src="../_images/circuit_index_graph_with_vit.pdf" style="width: 90%;" />
</a>
<figcaption>
<p><span class="caption-number">Fig. 3 </span><span class="caption-text">Index graph and associated index edge list and adjacency list
corresponding to the circuit graph example.
Also shown is the translation table from vertex to index.</span><a class="headerlink" href="#fig-circuit-index-to-adj" title="Link to this image"></a></p>
</figcaption>
</figure>
<figure class="align-center" id="fig-airport-index-to-adj">
<a class="reference internal image-reference" href="../_images/airport_index_graph_with_vit.pdf"><img alt="Airport index graph." src="../_images/airport_index_graph_with_vit.pdf" style="width: 90%;" />
</a>
<figcaption>
<p><span class="caption-number">Fig. 4 </span><span class="caption-text">Index graph and associated index edge list and adjacency list
corresponding to the airport graph example.
Also shown is the translation table from vertex to index.</span><a class="headerlink" href="#fig-airport-index-to-adj" title="Link to this image"></a></p>
</figcaption>
</figure>
<p>One of the fundamental operations in graph algorithms is a <em>traversal</em>.
That is, given a vertex <span class="math notranslate nohighlight">\(u\)</span>, we would like to find the <em>neighbors</em>
of <span class="math notranslate nohighlight">\(u\)</span>, i.e., all vertices <span class="math notranslate nohighlight">\(v\)</span> such that the edge
<span class="math notranslate nohighlight">\((u,v)\)</span> is in the graph. Then, for each of those edges, we would
like to find their neighbors, and so on. The representation that we can
define to make this efficient is an <em>adjacency list</em>.</p>
<p>Given a graph <span class="math notranslate nohighlight">\(G = (V,E)\)</span>, we can define an adjacency-list
representation in the following way. Assign to each element of <span class="math notranslate nohighlight">\(V\)</span>
a unique index from the range <span class="math notranslate nohighlight">\([0,|V|)\)</span> and denote the vertex
identified with index <span class="math notranslate nohighlight">\(i\)</span> as <span class="math notranslate nohighlight">\(V[i]\)</span>. We can now define a new
graph with the same structure as <span class="math notranslate nohighlight">\(G\)</span>, but in terms of the indices
in <span class="math notranslate nohighlight">\([0,|V|)\)</span>, rather than with the elements in <span class="math notranslate nohighlight">\(V\)</span>. Let the
<em>index graph of</em> <span class="math notranslate nohighlight">\(G\)</span> be the graph <span class="math notranslate nohighlight">\(G'=(V',E')\)</span>, where
<span class="math notranslate nohighlight">\(V'=[0,|V|)\)</span> and <span class="math notranslate nohighlight">\(E'\)</span> consists of <span class="math notranslate nohighlight">\(|E|\)</span> pairs of
indices from <span class="math notranslate nohighlight">\(V\)</span>, such that a pair <span class="math notranslate nohighlight">\((i,j)\)</span> is in E’ if and
only if <span class="math notranslate nohighlight">\((V[i],V[j])\)</span> is in <span class="math notranslate nohighlight">\(E\)</span>. Which is all to say, the
index graph of <span class="math notranslate nohighlight">\(G\)</span> is the graph we get by replacing all elements
of <span class="math notranslate nohighlight">\(G\)</span> with their corresponding indices.
<a class="reference internal" href="#fig-circuit-index-to-adj"><span class="std std-numref">Fig. 3</span></a>
and
<a class="reference internal" href="#fig-airport-index-to-adj"><span class="std std-numref">Fig. 4</span></a>
show the
progression from an index graph to an index adjacency list (compare also
to
<a class="reference internal" href="#fig-graph-model-circuit"><span class="std std-numref">Fig. 1</span></a> and
<a class="reference internal" href="#fig-graph-model-airports"><span class="std std-numref">Fig. 2</span></a>).
Since edges are given in terms
of vertex names, in order to create a list of edge indices, we need to
translate from vertex name to vertex index. Accordingly,
<a class="reference internal" href="#fig-circuit-index-to-adj"><span class="std std-numref">Fig. 3</span></a>
and
<a class="reference internal" href="#fig-airport-index-to-adj"><span class="std std-numref">Fig. 4</span></a>
also
show the translation table
from vertex to index.</p>
<p>Of course, we don’t need an underlying graph to define what an index
graph itself is. We can say that a graph <span class="math notranslate nohighlight">\(G = (V, E)\)</span> is an index
graph if its vertex set is a set of contiguous indices, i.e., with
<span class="math notranslate nohighlight">\(V=[0,|V|-1)\)</span>. Since an index graph is just a graph, in cases
where the context is clear, we may refer to an index graph simply as a
graph. We note that an adjacency list can only be defined over an index
graph.</p>
<p>Finally, we can make the following precise definition: An <em>adjacency
list</em> of an index graph <span class="math notranslate nohighlight">\(G=(V,E)\)</span> is an array <span class="math notranslate nohighlight">\(Adj(G)\)</span> of
size <span class="math notranslate nohighlight">\(|V|\)</span> (the array is indexed from <span class="math notranslate nohighlight">\(0\)</span> to <span class="math notranslate nohighlight">\(|V|-1\)</span>)
with the following properties:</p>
<ul class="simple">
<li><p><span class="math notranslate nohighlight">\(Adj(G)\)</span> is a container of <span class="math notranslate nohighlight">\(|V|\)</span> containers, one
container for each vertex in <span class="math notranslate nohighlight">\(V\)</span>, and</p></li>
<li><p>The container <span class="math notranslate nohighlight">\(Adj(G)[u]\)</span> contains all vertices <span class="math notranslate nohighlight">\(v\)</span> for
which there is an edge <span class="math notranslate nohighlight">\((u,v)\in E\)</span>.</p></li>
</ul>
<p>This structure, <strong>an adjacency list of an index graph, or an index
adjacency list, is the fundamental structure used by almost all graph
algorithms.</strong> and show the index graph and the adjacency list
representation of our airport and circuit examples.</p>
<p><strong>Remark (1):</strong> Although the standard term for this kind of abstraction
is “adjacency list”, and although it is often drawn schematically with
linked lists as elements, it is not necessary that this abstraction be
implemented as an actual linked list. In fact, other representations are
significantly more efficient. <strong>What is important is that the items that
are stored, vertex indices, can be used to index into the adjacency list
to obtain other lists of neighbors.</strong></p>
<p><strong>Remark (2):</strong> The index adjacency list does not store edges per se,
rather it stores lists of reachable neighbors. Therefore, the index
adjacency list is neither inherently directed nor undirected. That is,
for a given vertex <span class="math notranslate nohighlight">\(u\)</span>, the container <span class="math notranslate nohighlight">\(Adj(G)[u]\)</span> contains
the vertex <span class="math notranslate nohighlight">\(v\)</span> if the edge <span class="math notranslate nohighlight">\((u,v)\)</span> is contained in
<span class="math notranslate nohighlight">\(E\)</span>. This means that for a directed graph with edge <span class="math notranslate nohighlight">\((u,v)\)</span>
in , <span class="math notranslate nohighlight">\(E\)</span>, <span class="math notranslate nohighlight">\(Adj(G)[u]\)</span> will contain <span class="math notranslate nohighlight">\(v\)</span>. For an
undirected graph with edge <span class="math notranslate nohighlight">\((u,v)\)</span> is contained in <span class="math notranslate nohighlight">\(E\)</span>,
<span class="math notranslate nohighlight">\(Adj(G)[u]\)</span> will contain <span class="math notranslate nohighlight">\(v\)</span> and <span class="math notranslate nohighlight">\(Adj(G)[v]\)</span> will
contain <span class="math notranslate nohighlight">\(u\)</span>. <strong>Directedness of the original graph is thus made
manifest in the values stored in the index adjacency list.</strong></p>
<p>Compare, for instance, the adjacency lists in
<a class="reference internal" href="#fig-circuit-index-to-adj"><span class="std std-numref">Fig. 3</span></a>
and
<a class="reference internal" href="#fig-airport-index-to-adj"><span class="std std-numref">Fig. 4</span></a>.
The
graphs have the same structure in the schematics and in the mathematical
notations (shown in
<a class="reference internal" href="#fig-graph-model-circuit"><span class="std std-numref">Fig. 1</span></a> and
<a class="reference internal" href="#fig-graph-model-airports"><span class="std std-numref">Fig. 2</span></a>).
However, when realized as
adjacency list, the adjacency list in
<a class="reference internal" href="#fig-graph-model-airports"><span class="std std-numref">Fig. 2</span></a>
is symmetrized. Every edge
<span class="math notranslate nohighlight">\(\{u,v\}\)</span> in the graph is inserted twice into the adjacency list:
once as <span class="math notranslate nohighlight">\(\{u,v\}\)</span> and once as <span class="math notranslate nohighlight">\(\{v,u\}\)</span>.</p>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="introduction.html" class="btn btn-neutral float-left" title="NWGraph: The Northwest Graph Library" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="generic-programming.html" class="btn btn-neutral float-right" title="Generic Programming in C++20" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2020-2022, PNNL, UW.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>