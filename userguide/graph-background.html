

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../">
<head>
  <meta charset="utf-8" /><meta name="viewport" content="width=device-width, initial-scale=1" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Graph Background &mdash; NW Graph 0.10.15 documentation</title>
      <link rel="stylesheet" type="text/css" href="../_static/pygments.css?v=649a27d8" />
      <link rel="stylesheet" type="text/css" href="../_static/css/theme.css?v=9edc463e" />
      <link rel="stylesheet" type="text/css" href="../_static/graphviz.css?v=4ae1632d" />
      <link rel="stylesheet" type="text/css" href="../_static/collapsible-lists/css/tree_view.css?v=a885cde7" />
      <link rel="stylesheet" type="text/css" href="../_static/css/custom.css?v=afbbf639" />

  
      <script src="../_static/jquery.js?v=5d32c60e"></script>
      <script src="../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="../_static/documentation_options.js?v=a8af70a8"></script>
      <script src="../_static/doctools.js?v=fd6eb6e6"></script>
      <script src="../_static/sphinx_highlight.js?v=6ffebe34"></script>
      <script src="../_static/collapsible-lists/js/CollapsibleLists.compressed.js?v=73120307"></script>
      <script src="../_static/collapsible-lists/js/apply-collapsible-lists.js?v=660e4f45"></script>
      <script>window.MathJax = {"TeX": {"Macros": {"RR": "{\\mathbb R}", "Real": "{\\mathbb R}", "Complex": "{\\mathbb C}", "mat": ["{\\mathbf{#1}}", 1], "vec": ["{\\mathbf{#1}}", 1], "bold": ["{\\bf #1}", 1], "Spc": ["\\mathbb{#1}", 1], "norm": ["|| #1 ||", 1]}}}</script>
      <script defer="defer" src="https://cdn.jsdelivr.net/npm/mathjax@4/tex-mml-chtml.js"></script>
    <script src="../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../index.html" class="icon icon-home">
            NW Graph
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul>
<li class="toctree-l1"><a class="reference internal" href="getting_started.html">Quickstart</a></li>
<li class="toctree-l1"><a class="reference internal" href="benchmarking.html">Benchmarking with NWGraph</a></li>
<li class="toctree-l1"><a class="reference internal" href="introduction.html">NWGraph: The Northwest Graph Library</a></li>
<li class="toctree-l1"><a class="reference internal" href="graph-background-ii.html">Graph Background</a></li>
<li class="toctree-l1"><a class="reference internal" href="generic-programming.html">Generic Programming in C++20</a></li>
<li class="toctree-l1"><a class="reference internal" href="graph-concepts.html">Generic Graph Algorithms</a></li>
<li class="toctree-l1"><a class="reference internal" href="algorithms.html">NWGraph Algorithms</a></li>
<li class="toctree-l1"><a class="reference internal" href="adaptors.html">Graph Range Adaptors</a></li>
<li class="toctree-l1"><a class="reference internal" href="data-structures.html">Model Data Structures</a></li>
<li class="toctree-l1"><a class="reference internal" href="performance.html">Performance Evaluation</a></li>
<li class="toctree-l1"><a class="reference internal" href="related.html">Related Libraries and Toolkits</a></li>
<li class="toctree-l1"><a class="reference internal" href="references.html">References Cited</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../examples/index.html">Examples</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../nwgraph_api.html">NWGraph API Reference</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">NW Graph</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../index.html" class="icon icon-home" aria-label="Home"></a></li>
      <li class="breadcrumb-item active">Graph Background</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../_sources/userguide/graph-background.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="graph-background">
<span id="sec-graph-background"></span><h1>Graph Background<a class="headerlink" href="#graph-background" title="Link to this heading"></a></h1>
<p>We define a <em>graph</em> <span class="math notranslate nohighlight">\(G\)</span> as comprising two finite sets,
<span class="math notranslate nohighlight">\(G =\{ V, E \}\)</span>, where the set
<span class="math notranslate nohighlight">\(V= \{ v_0, v_1, \ldots v_{n-1} \}\)</span> is a set of entities of
interest, “vertices” or “nodes,” and
<span class="math notranslate nohighlight">\(E = \{ e_0, e_1, \ldots e_{m-1} \}\)</span> is a set of pairs of entities
from <span class="math notranslate nohighlight">\(V\)</span>, “edges” or “links.” Edges may be ordered or unordered; a
graph defined with ordered edges is said to be <em>directed</em>; a graph
defined with unordered edges is said to be <em>undirected</em>.</p>
<p><strong>Remark.</strong> Understanding graphs is necessary to develop requirements
for algorithms. However, it should be noted that we don’t derive those
requirements from the graph model, but <em>instead from the algorithms</em>.
This is a key distinction between generic programming and, say,
Object-oriented (OO) requirements analysis.</p>
<section id="representing-graphs">
<span id="sec-representing-graphs"></span><h2>Representing Graphs<a class="headerlink" href="#representing-graphs" title="Link to this heading"></a></h2>
<p>To define algorithms on graphs and to be able to reason about those
algorithms, we need to define some representations for graphs; not much
can be done computationally with abstract sets of vertices and edges.
The specific characteristics of these representations are what we use to
express algorithms (still abstractly) but when those algorithms are
implemented as generic library functions, those characteristics will in
turn become the basis for the library’s interfaces (represented in our
case as C++ concepts).</p>
<p>One of the fundamental operations in graph algorithms is a <em>traversal</em>.
That is, given a vertex <span class="math notranslate nohighlight">\(u\)</span>, we would like to find the <em>neighbors</em>
of <span class="math notranslate nohighlight">\(u\)</span>, i.e., all vertices <span class="math notranslate nohighlight">\(v\)</span> such that the edge
<span class="math notranslate nohighlight">\((u,v)\)</span> is in the graph. Then, for each of those edges, we would
like to find their neighbors, and so on. The representation that we can
define to make this efficient is an <em>adjacency list</em>.</p>
<p>Given a graph <span class="math notranslate nohighlight">\(G = (V,E)\)</span>, we can define an adjacency-list
representation in the following way. Assign to each element of <span class="math notranslate nohighlight">\(V\)</span>
a unique index from the range <span class="math notranslate nohighlight">\([0,|V|)\)</span> and denote the vertex
identified with index <span class="math notranslate nohighlight">\(i\)</span> as <span class="math notranslate nohighlight">\(V[i]\)</span>. We can now define a new
graph with the same structure as <span class="math notranslate nohighlight">\(G\)</span>, but in terms of the indices
in <span class="math notranslate nohighlight">\([0,|V|)\)</span>, rather than with the elements in <span class="math notranslate nohighlight">\(V\)</span>. Let the
<em>index graph of</em> <span class="math notranslate nohighlight">\(G\)</span> be the graph <span class="math notranslate nohighlight">\(G'=(V',E')\)</span>, where
<span class="math notranslate nohighlight">\(V'=[0,|V|)\)</span> and <span class="math notranslate nohighlight">\(E'\)</span> consists of <span class="math notranslate nohighlight">\(|E|\)</span> pairs of
indices from <span class="math notranslate nohighlight">\(V\)</span>, such that a pair <span class="math notranslate nohighlight">\((i,j)\)</span> is in E’ if and
only if <span class="math notranslate nohighlight">\((V[i],V[j])\)</span> is in <span class="math notranslate nohighlight">\(E\)</span>. Which is all to say, the
index graph of <span class="math notranslate nohighlight">\(G\)</span> is the graph we get by replacing all elements
of <span class="math notranslate nohighlight">\(G\)</span> with their corresponding indices.</p>
<p>We make the following precise definition: An <em>adjacency list</em> of an
index graph <span class="math notranslate nohighlight">\(G=(V,E)\)</span> is an array <span class="math notranslate nohighlight">\(Adj(G)\)</span> of size
<span class="math notranslate nohighlight">\(|V|\)</span> (the array is indexed from <span class="math notranslate nohighlight">\(0\)</span> to <span class="math notranslate nohighlight">\(|V|-1\)</span>) with
the following properties:</p>
<ul class="simple">
<li><p><span class="math notranslate nohighlight">\(Adj(G)\)</span> is a container of <span class="math notranslate nohighlight">\(|V|\)</span> containers, one
container for each vertex in <span class="math notranslate nohighlight">\(V\)</span>, and</p></li>
<li><p>The container <span class="math notranslate nohighlight">\(Adj(G)[u]\)</span> contains all vertices <span class="math notranslate nohighlight">\(v\)</span> for
which there is an edge <span class="math notranslate nohighlight">\((u,v)\in E\)</span>.</p></li>
</ul>
<p>This structure, an adjacency list of an index graph, or an index
adjacency list, is the fundamental structure used by almost all graph
algorithms.</p>
<p><strong>Remark:</strong> Although the standard term for this kind of abstraction is
“adjacency list”, and although it is often drawn schematically with
linked lists as elements, it is not necessary that this abstraction be
implemented as an actual linked list. In fact, other representations
(such as compressed sparse row storage) are significantly more
efficient. What is important is that the items that are stored, vertex
indices, can be used to index into the adjacency list to obtain other
lists of neighbors.</p>
</section>
</section>


           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2020-2022, PNNL, UW.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>