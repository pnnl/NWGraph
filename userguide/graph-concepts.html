

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../">
<head>
  <meta charset="utf-8" /><meta name="viewport" content="width=device-width, initial-scale=1" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Generic Graph Algorithms &mdash; NW Graph 0.10.15 documentation</title>
      <link rel="stylesheet" type="text/css" href="../_static/pygments.css?v=649a27d8" />
      <link rel="stylesheet" type="text/css" href="../_static/css/theme.css?v=9edc463e" />
      <link rel="stylesheet" type="text/css" href="../_static/graphviz.css?v=4ae1632d" />
      <link rel="stylesheet" type="text/css" href="../_static/collapsible-lists/css/tree_view.css?v=a885cde7" />
      <link rel="stylesheet" type="text/css" href="../_static/css/custom.css?v=afbbf639" />

  
      <script src="../_static/jquery.js?v=5d32c60e"></script>
      <script src="../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="../_static/documentation_options.js?v=a8af70a8"></script>
      <script src="../_static/doctools.js?v=fd6eb6e6"></script>
      <script src="../_static/sphinx_highlight.js?v=6ffebe34"></script>
      <script src="../_static/collapsible-lists/js/CollapsibleLists.compressed.js?v=73120307"></script>
      <script src="../_static/collapsible-lists/js/apply-collapsible-lists.js?v=660e4f45"></script>
      <script>window.MathJax = {"TeX": {"Macros": {"RR": "{\\mathbb R}", "Real": "{\\mathbb R}", "Complex": "{\\mathbb C}", "mat": ["{\\mathbf{#1}}", 1], "vec": ["{\\mathbf{#1}}", 1], "bold": ["{\\bf #1}", 1], "Spc": ["\\mathbb{#1}", 1], "norm": ["|| #1 ||", 1]}}}</script>
      <script defer="defer" src="https://cdn.jsdelivr.net/npm/mathjax@4/tex-mml-chtml.js"></script>
    <script src="../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="NWGraph Algorithms" href="algorithms.html" />
    <link rel="prev" title="Generic Programming in C++20" href="generic-programming.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../index.html" class="icon icon-home">
            NW Graph
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="getting_started.html">Quickstart</a></li>
<li class="toctree-l1"><a class="reference internal" href="benchmarking.html">Benchmarking with NWGraph</a></li>
<li class="toctree-l1"><a class="reference internal" href="introduction.html">NWGraph: The Northwest Graph Library</a></li>
<li class="toctree-l1"><a class="reference internal" href="graph-background-ii.html">Graph Background</a></li>
<li class="toctree-l1"><a class="reference internal" href="generic-programming.html">Generic Programming in C++20</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Generic Graph Algorithms</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#algorithm-requirements">Algorithm Requirements</a></li>
<li class="toctree-l2"><a class="reference internal" href="#requirements-for-concrete-algorithms">Requirements for Concrete Algorithms</a></li>
<li class="toctree-l2"><a class="reference internal" href="#lifting">Lifting</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#parameterizing-the-graph-type">Parameterizing the Graph Type</a></li>
<li class="toctree-l3"><a class="reference internal" href="#lifting-neighbor-access">Lifting Neighbor Access</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#graph-concepts-encapsulating-lifted-requirements">Graph Concepts: Encapsulating Lifted Requirements</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#lifting-edge-weight">Lifting Edge Weight</a></li>
<li class="toctree-l3"><a class="reference internal" href="#non-type-constraints">Non-Type Constraints</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#other-concepts">Other Concepts</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="algorithms.html">NWGraph Algorithms</a></li>
<li class="toctree-l1"><a class="reference internal" href="adaptors.html">Graph Range Adaptors</a></li>
<li class="toctree-l1"><a class="reference internal" href="data-structures.html">Model Data Structures</a></li>
<li class="toctree-l1"><a class="reference internal" href="performance.html">Performance Evaluation</a></li>
<li class="toctree-l1"><a class="reference internal" href="related.html">Related Libraries and Toolkits</a></li>
<li class="toctree-l1"><a class="reference internal" href="references.html">References Cited</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../examples/index.html">Examples</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../nwgraph_api.html">NWGraph API Reference</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">NW Graph</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../index.html" class="icon icon-home" aria-label="Home"></a></li>
      <li class="breadcrumb-item active">Generic Graph Algorithms</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../_sources/userguide/graph-concepts.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="generic-graph-algorithms">
<span id="sec-concepts"></span><h1>Generic Graph Algorithms<a class="headerlink" href="#generic-graph-algorithms" title="Link to this heading"></a></h1>
<p>In this section we analyze the requirements for graph algorithms in
order to derive generic graph algorithms. In NWGraph, these generic
algorithms are realized as function templates, and the type requirements
are realized as C++20 <code class="docutils literal notranslate"><span class="pre">concept</span></code>s. Our process centers on defining
type requirements at the interfaces to algorithms based on what the
algorithms actually need from their types, rather than starting with
graph types and building algorithms to those types.</p>
<section id="algorithm-requirements">
<span id="sec-algorithm-requirements"></span><h2>Algorithm Requirements<a class="headerlink" href="#algorithm-requirements" title="Link to this heading"></a></h2>
<p>Algorithms in the STL operate over containers. The concepts defined for
the STL have to do with mechanisms for traversing a container and
accessing the data therein. Since graphs in some sense are also
containers of data, we can reuse the mechanisms from the STL for
traversing graphs and accessing graph data, to the extent that makes
sense. However, graphs are <em>structured data</em> and graph algorithms
traverse that structure in various ways. Accordingly, our graph concepts
must support structured traversal of graphs.</p>
<p>Most (but not all) graph algorithms traverse a graph vertex to vertex by
following the edges that connect vertices. For implementing such
algorithms, it is assumed that a graph <span class="math notranslate nohighlight">\(G = \{V, E\}\)</span> is
represented with an adjacency-list structure  <a href="#id2"><span class="problematic" id="id1">[1]_</span></a> as defined in .</p>
</section>
<section id="requirements-for-concrete-algorithms">
<span id="sec-requirements-concrete-alg"></span><h2>Requirements for Concrete Algorithms<a class="headerlink" href="#requirements-for-concrete-algorithms" title="Link to this heading"></a></h2>
<p>A prototypical algorithm in this class is the breadth-first search (BFS)
algorithm. The pseudocode for this algorithm, along with its C++
implementation is shown in Fig. <a class="reference external" href="#fig:bfs">[fig:bfs]</a>. The algorithm
is abbreviated from:cite:<cite>cormen2009introduction</cite>. Modulo
some type declarations that would be necessary for real code to compile,
but which can be omitted from pseudocode, the C++ code, using out of the
box language mechanisms and library components, has essentially a
one-one correspondence to the pseudocode.</p>
<div class="figure docutils container">
<div class="codebox docutils container">
<p><span class="math notranslate nohighlight">\(\displaystyle color[u] \gets \const{\textsc{white}}\)</span>
<span class="math notranslate nohighlight">\(\displaystyle u\gets\proc{Dequeue}{(Q)}\)</span>
<span class="math notranslate nohighlight">\(\displaystyle  color[v] \gets \const{gray}\)</span></p>
</div>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">bfs</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">Graph</span><span class="o">&amp;</span><span class="w"> </span><span class="n">G</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">s</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="p">...</span>
<span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">u</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">u</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">size</span><span class="p">(</span><span class="n">G</span><span class="p">);</span><span class="w"> </span><span class="o">++</span><span class="n">u</span><span class="p">)</span>
<span class="w">    </span><span class="n">color</span><span class="p">[</span><span class="n">u</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">WHITE</span><span class="p">;</span>
<span class="w">  </span><span class="n">color</span><span class="p">[</span><span class="n">s</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">GREY</span><span class="p">;</span>
<span class="w">  </span><span class="n">std</span><span class="o">::</span><span class="n">queue</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">Q</span><span class="p">;</span>
<span class="w">  </span><span class="n">Q</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>
<span class="w">  </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">Q</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">auto</span><span class="w"> </span><span class="n">u</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Q</span><span class="p">.</span><span class="n">front</span><span class="p">();</span><span class="w">    </span><span class="n">Q</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="k">auto</span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">v</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">G</span><span class="p">[</span><span class="n">u</span><span class="p">])</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">color</span><span class="p">[</span><span class="n">v</span><span class="p">]</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">WHITE</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">color</span><span class="p">[</span><span class="n">v</span><span class="p">]</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">GREY</span><span class="p">;</span>
<span class="w">        </span><span class="n">Q</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">v</span><span class="p">);</span><span class="w">            </span><span class="p">}}</span>
<span class="w">    </span><span class="n">color</span><span class="p">[</span><span class="n">u</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">BLACK</span><span class="p">;</span><span class="w">         </span><span class="p">}}</span>
</pre></div>
</div>
</div>
<p>From this implementation we can extract an initial set of requirements
for the BFS algorithm:</p>
<ul class="simple">
<li><p>The graph <code class="docutils literal notranslate"><span class="pre">G</span></code> is a <em>random access range</em>, meaning it can be indexed
into with an object (of its difference type) and it has a size.</p></li>
<li><p>The value type of <code class="docutils literal notranslate"><span class="pre">G</span></code> (the inner range of <code class="docutils literal notranslate"><span class="pre">G</span></code>) is a <em>forward
range</em>, meaning it is something that can be iterated over and have
values extracted.</p></li>
<li><p>The value type of the inner range is something that can be used to
index into <code class="docutils literal notranslate"><span class="pre">G</span></code>.</p></li>
<li><p>All elements stored in <code class="docutils literal notranslate"><span class="pre">G</span></code> must be able to correctly index into it,
meaning their value are between 0 and <code class="docutils literal notranslate"><span class="pre">size(G)-1</span></code>, inclusive.</p></li>
</ul>
<p>Associated with the concepts of a random access range and forward range
are complexity guarantees (which are also implied by the theoretical
algorithm). Indexing into <code class="docutils literal notranslate"><span class="pre">G</span></code> is a constant-time operation and
iterating over the elements in <code class="docutils literal notranslate"><span class="pre">G[u]</span></code> is linear in the number of
elements stored in <code class="docutils literal notranslate"><span class="pre">G[u]</span></code>.</p>
<p>As an example, we could use any of the following compositions of
standard library components for the <code class="docutils literal notranslate"><span class="pre">Graph</span></code> datatype above:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">using</span><span class="w"> </span><span class="n">Graph</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">list</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;</span><span class="p">;</span>
<span class="k">using</span><span class="w"> </span><span class="n">Graph</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">unsigned</span><span class="o">&gt;&gt;</span><span class="p">;</span>
<span class="k">using</span><span class="w"> </span><span class="n">Graph</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">forward_list</span><span class="o">&lt;</span><span class="kt">size_t</span><span class="o">&gt;&gt;</span><span class="p">;</span>
</pre></div>
</div>
<p>In fact, any <code class="docutils literal notranslate"><span class="pre">Graph</span></code> data structure meeting the above requirements
could be used.</p>
<p>We now have a set of requirements for a concrete implementation of BFS.
Following the generic programming process, there are various aspects of
the implementation that we could begin lifting. Ultimately, as with the
STL, we want a set of concepts useful across families of graph
algorithms. So rather than lifting BFS in isolation, we now examine
concrete implementations of other algorithms in order to identify common
functionality that can be lifted in order to unify abstractions.</p>
<div class="figure docutils container">
<div class="codebox docutils container">
<p><span class="math notranslate nohighlight">\(\displaystyle d[u] \gets \infty\)</span>
<span class="math notranslate nohighlight">\(\displaystyle u\gets\proc{Extract-Min}{(Q)}\)</span>
<span class="math notranslate nohighlight">\(d[v] \gets d[u] + w(u,v)\)</span></p>
</div>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">dijkstra</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">Graph</span><span class="o">&amp;</span><span class="w"> </span><span class="n">G</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">s</span><span class="p">)</span><span class="w"> </span><span class="p">{...</span>
<span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">u</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">u</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">size</span><span class="p">(</span><span class="n">G</span><span class="p">);</span><span class="w"> </span><span class="o">++</span><span class="n">u</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">d</span><span class="p">[</span><span class="n">u</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">INF</span><span class="p">;</span>
<span class="w">    </span><span class="n">pi</span><span class="p">[</span><span class="n">u</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">NIL</span><span class="p">;</span><span class="w">                    </span><span class="p">}</span>
<span class="w">  </span><span class="n">d</span><span class="p">[</span><span class="n">s</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span>
<span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">u</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">u</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">size</span><span class="p">(</span><span class="n">G</span><span class="p">);</span><span class="w"> </span><span class="o">++</span><span class="n">u</span><span class="p">)</span>
<span class="w">    </span><span class="n">Q</span><span class="p">.</span><span class="n">push</span><span class="p">({</span><span class="n">u</span><span class="p">,</span><span class="w"> </span><span class="n">d</span><span class="p">[</span><span class="n">u</span><span class="p">]});</span>
<span class="w">  </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">Q</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">auto</span><span class="w"> </span><span class="p">[</span><span class="n">u</span><span class="p">,</span><span class="w"> </span><span class="n">x</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Q</span><span class="p">.</span><span class="n">top</span><span class="p">();</span><span class="w"> </span><span class="n">Q</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="k">auto</span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="p">[</span><span class="n">v</span><span class="p">,</span><span class="w"> </span><span class="n">w</span><span class="p">]</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">G</span><span class="p">[</span><span class="n">u</span><span class="p">])</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">d</span><span class="p">[</span><span class="n">u</span><span class="p">]</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">w</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">d</span><span class="p">[</span><span class="n">v</span><span class="p">])</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">d</span><span class="p">[</span><span class="n">v</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">d</span><span class="p">[</span><span class="n">u</span><span class="p">]</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">w</span><span class="p">;</span>
<span class="w">        </span><span class="n">pi</span><span class="p">[</span><span class="n">v</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">u</span><span class="p">;</span><span class="w">               </span><span class="p">}}}}</span>
</pre></div>
</div>
</div>
<p>Fig. <a class="reference external" href="#fig:dijkstra">[fig:dijkstra]</a> shows the pseudocode and
corresponding C++ implementation for Dijksra’s algorithm for solving the
single-source shortest paths problem. From this implementation we can
extract an initial set of requirements for the concrete <code class="docutils literal notranslate"><span class="pre">dijkstra</span></code>
algorithm:</p>
<ul class="simple">
<li><p>The graph <code class="docutils literal notranslate"><span class="pre">G</span></code> is a <em>random access range</em>.</p></li>
<li><p>The value type of <code class="docutils literal notranslate"><span class="pre">G</span></code> (the inner range of <code class="docutils literal notranslate"><span class="pre">G</span></code>) is a <em>forward
range</em>.</p></li>
<li><p>The value type of the inner range is a pair, consisting of a
something we will call a vertex type and something we will call a
weight.</p></li>
<li><p>The vertex type is something that can be used to index into <code class="docutils literal notranslate"><span class="pre">G</span></code>.</p></li>
<li><p>All values stored as vertex types in <code class="docutils literal notranslate"><span class="pre">G</span></code> must be able to correctly
index into <code class="docutils literal notranslate"><span class="pre">G</span></code> meaning their value are between 0 and <code class="docutils literal notranslate"><span class="pre">size(G)-1</span></code>,
inclusive.</p></li>
</ul>
<p>Just as the code of <code class="docutils literal notranslate"><span class="pre">dijkstra</span></code> is similar to <code class="docutils literal notranslate"><span class="pre">bfs</span></code>, some of these
requirements are also the same. <strong>However, the key difference is in what
is stored inside of the graph</strong>. This implementation of <code class="docutils literal notranslate"><span class="pre">dijkstra</span></code>
assumes that the graph stores a tuple consisting of <em>a vertex value and
an edge weight</em>. That is, rather than the <code class="docutils literal notranslate"><span class="pre">Graph</span></code> types shown above,
we could use the following for <code class="docutils literal notranslate"><span class="pre">dijkstra</span></code>:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">using</span><span class="w"> </span><span class="n">Graph</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">list</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="kt">size_t</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="o">&gt;&gt;&gt;</span><span class="p">;</span>
<span class="k">using</span><span class="w"> </span><span class="n">Graph</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="kt">unsigned</span><span class="p">,</span><span class="w"> </span><span class="kt">double</span><span class="o">&gt;&gt;&gt;</span><span class="p">;</span>
<span class="k">using</span><span class="w"> </span><span class="n">Graph</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">forward_list</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="kt">float</span><span class="o">&gt;&gt;&gt;</span><span class="p">;</span>
</pre></div>
</div>
<p>This is a different kind of graph than we had for <code class="docutils literal notranslate"><span class="pre">bfs</span></code>, which only
stored a value. Yet, even a graph that stores a weight on its edge is
suitable for BFS exploration. Similarly, a graph without a weight on its
edge should be suitable for Dijkstra’s algorithm, provided a weight
value can be provided in some way, or a default value, say, 1, used.</p>
</section>
<section id="lifting">
<span id="subsec-lifting-graph"></span><h2>Lifting<a class="headerlink" href="#lifting" title="Link to this heading"></a></h2>
<p>From the foregoing discussion, we have two pieces of functionality we
need to lift. First, we need to lift how the neighbor vertex is stored
so that whether it is stored as a direct value or as part of a tuple (or
any other way), it can be obtained. Second, we need to lift how weights
(or, more generally, <strong>properties</strong>) are stored on edges. And, finally,
implied when we say we want to use different kinds of graphs with these
algorithms, we need to parameterize them on the graph type (make them
function templates rather than functions).</p>
<section id="parameterizing-the-graph-type">
<h3>Parameterizing the Graph Type<a class="headerlink" href="#parameterizing-the-graph-type" title="Link to this heading"></a></h3>
<p>In this lifting process we will be building up to a concept, which we
will illustrate by lifting <code class="docutils literal notranslate"><span class="pre">dijkstra</span></code>. We begin by presenting its type
parameterization. The prototype for a <code class="docutils literal notranslate"><span class="pre">dijkstra</span></code> function template
based on our previous definition would be</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">class</span><span class="w"> </span><span class="nc">Graph</span><span class="o">&gt;</span>
<span class="k">auto</span><span class="w"> </span><span class="n">dijkstra</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">Graph</span><span class="o">&amp;</span><span class="w"> </span><span class="n">G</span><span class="p">,</span><span class="w"> </span><span class="n">vertex_id_t</span><span class="o">&lt;</span><span class="n">G</span><span class="o">&gt;</span><span class="w"> </span><span class="n">s</span><span class="p">);</span>
</pre></div>
</div>
<p>Note that we have parameterized <em>two</em> things: the <code class="docutils literal notranslate"><span class="pre">Graph</span></code> type itself,
as well as the type of the starting vertex <code class="docutils literal notranslate"><span class="pre">s</span></code>. In this case, the
vertex type is not arbitrary, it is related to the type of the graph,
and so we have a type primitive <code class="docutils literal notranslate"><span class="pre">vertex_id_t</span></code> that returns the type of
the vertex associated with graph <code class="docutils literal notranslate"><span class="pre">G</span></code>.</p>
<p>We can update some of the previous requirements for the
type-parameterized <code class="docutils literal notranslate"><span class="pre">dijkstra</span></code>:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">Graph</span></code> must meet the requirements of <code class="docutils literal notranslate"><span class="pre">random_access_range</span></code>.</p></li>
<li><p>The value type of <code class="docutils literal notranslate"><span class="pre">Graph</span></code> (the inner range of <code class="docutils literal notranslate"><span class="pre">Graph</span></code>) must meet
the requirements of <code class="docutils literal notranslate"><span class="pre">forward_range</span></code>.</p></li>
<li><p>The type <code class="docutils literal notranslate"><span class="pre">vertex_id_t&lt;Graph&gt;</span></code> is an associated type of <code class="docutils literal notranslate"><span class="pre">Graph</span></code>.</p></li>
<li><p>The type <code class="docutils literal notranslate"><span class="pre">vertex_id_t&lt;Graph&gt;</span></code> is convertible to the
<code class="docutils literal notranslate"><span class="pre">range_difference_t</span></code> of <code class="docutils literal notranslate"><span class="pre">Graph</span></code> (that is, it can be used to index
into a <code class="docutils literal notranslate"><span class="pre">Graph</span></code>).</p></li>
</ul>
<p>Both classes of graphs that we had previously seen for <code class="docutils literal notranslate"><span class="pre">bfs</span></code> and
<code class="docutils literal notranslate"><span class="pre">dijkstra</span></code> satisfy these requirements (which are more general than
either of the previous requirements). For example, both of the following
compound structures</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;</span><span class="p">;</span>
<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="kt">float</span><span class="p">,</span><span class="w"> </span><span class="kt">double</span><span class="o">&gt;&gt;&gt;</span><span class="p">;</span>
</pre></div>
</div>
<p>satisfy the lifted requirements, (provided a suitable overload of
<code class="docutils literal notranslate"><span class="pre">vertex_id_t</span></code> is defined) though each would have only satisfied one of
the previous requirements. Note however, we still need to do more
lifting before we can actually compose <code class="docutils literal notranslate"><span class="pre">bfs</span></code> or <code class="docutils literal notranslate"><span class="pre">dijkstra</span></code> with
these types.</p>
</section>
<section id="lifting-neighbor-access">
<h3>Lifting Neighbor Access<a class="headerlink" href="#lifting-neighbor-access" title="Link to this heading"></a></h3>
<p>How a neighbor is stored is dependent on the graph structure itself. We
want the mechanism for accessing it therefore to vary based on the graph
type. In keeping with standard C++ practice – and since we want to be
able to use with C++ standard library containers, we adopt a polymorphic
free function interface to abstract the process of accessing a neighbor.
In particular, we define a <code class="docutils literal notranslate"><span class="pre">target</span></code> <em>customization point object</em> (CPO)
to abstract how a neighbor vertex is accessed, given an object obtained
from traversing the neighbor list.</p>
<ul class="simple">
<li><p>If variable <code class="docutils literal notranslate"><span class="pre">G</span></code> is of type <code class="docutils literal notranslate"><span class="pre">Graph</span></code> and variable <code class="docutils literal notranslate"><span class="pre">e</span></code> is of the
value type of the inner range of <code class="docutils literal notranslate"><span class="pre">Graph</span></code>, then <code class="docutils literal notranslate"><span class="pre">target(G,</span> <span class="pre">e)</span></code> is
a valid expression that returns a type of <code class="docutils literal notranslate"><span class="pre">vertex_id_t&lt;Graph&gt;</span></code>.</p></li>
<li><p>All values returned by <code class="docutils literal notranslate"><span class="pre">target(G,</span> <span class="pre">e)</span></code> must be able to correctly
index into a <code class="docutils literal notranslate"><span class="pre">Graph</span></code> <code class="docutils literal notranslate"><span class="pre">G</span></code>.</p></li>
</ul>
<p>With this abstraction, the loop and neighbor access in <code class="docutils literal notranslate"><span class="pre">bfs</span></code> and
<code class="docutils literal notranslate"><span class="pre">dijkstra</span></code> (respectively at
lines <a class="reference external" href="#bfs:foreach_v_in_Adj">[bfs:foreach_v_in_Adj]</a>
and <a class="reference external" href="#code:foreach-dijkstra">[code:foreach-dijkstra]</a>) are replaced
by</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="k">auto</span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">e</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">G</span><span class="p">[</span><span class="n">u</span><span class="p">])</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">auto</span><span class="w"> </span><span class="n">v</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">target</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="w"> </span><span class="n">e</span><span class="p">);</span>
<span class="w">  </span><span class="p">...</span><span class="w"> </span><span class="p">}</span>
</pre></div>
</div>
<p>Now, provided that suitable overloads for <code class="docutils literal notranslate"><span class="pre">target</span></code> are defined, the
two model graph types</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;</span><span class="p">;</span>
<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="kt">float</span><span class="p">,</span><span class="w"> </span><span class="kt">double</span><span class="o">&gt;&gt;&gt;</span><span class="p">;</span>
</pre></div>
</div>
<p>will satisfy the above requirements, and we can compose them with the
<code class="docutils literal notranslate"><span class="pre">bfs</span></code> and <code class="docutils literal notranslate"><span class="pre">dijkstra</span></code> we have lifted to this point.</p>
<p>We can, for example, define overloads for target thusly:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span><span class="w"> </span><span class="nf">target</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;&amp;</span><span class="w"> </span><span class="n">G</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">e</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">e</span><span class="p">;</span><span class="w"> </span><span class="p">}</span>
<span class="k">using</span><span class="w"> </span><span class="n">E</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="kt">float</span><span class="p">,</span><span class="w"> </span><span class="kt">double</span><span class="o">&gt;</span><span class="p">;</span>
<span class="kt">int</span><span class="w"> </span><span class="nf">target</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">E</span><span class="o">&gt;&gt;&amp;</span><span class="w"> </span><span class="n">G</span><span class="p">,</span><span class="w"> </span><span class="n">E</span><span class="o">&amp;</span><span class="w"> </span><span class="n">e</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">get</span><span class="o">&lt;</span><span class="mi">0</span><span class="o">&gt;</span><span class="p">(</span><span class="n">e</span><span class="p">);</span><span class="w"> </span><span class="p">}</span>
</pre></div>
</div>
<p>Note that these overloads are each specific to a single graph type. In
practice we can define generalized overloads for entire classes of
containers. In NWGraph we opted to realize <code class="docutils literal notranslate"><span class="pre">target</span></code> as a CPO,
implemented using the <code class="docutils literal notranslate"><span class="pre">tag_invoke</span></code>
mechanism:cite:<cite>_tag_invoke</cite>.</p>
</section>
</section>
<section id="graph-concepts-encapsulating-lifted-requirements">
<h2>Graph Concepts: Encapsulating Lifted Requirements<a class="headerlink" href="#graph-concepts-encapsulating-lifted-requirements" title="Link to this heading"></a></h2>
<p>We can encapsulate (and formalize) the above requirements in the form of
a concept (which is almost a direct translation of the stated
requirements to code).</p>
<p>We first capture the very fundamental requirements of a graph, that it
has an associated vertex id type:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">G</span><span class="o">&gt;</span>
<span class="k">concept</span><span class="w"> </span><span class="nc">graph</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">semiregular</span><span class="o">&lt;</span><span class="n">G</span><span class="o">&gt;</span>
<span class="w">    </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="k">requires</span><span class="p">(</span><span class="n">G</span><span class="w"> </span><span class="n">g</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">vertex_id_t</span><span class="o">&lt;</span><span class="n">G</span><span class="o">&gt;</span><span class="p">;</span><span class="w">  </span><span class="p">};</span>
</pre></div>
</div>
<p>We define this as a separate concept since we may wish to define other
concepts that reuse these requirements.</p>
<p>Next, we define some convenience type aliases to capture the type of the
inner range of a graph as well as the type that is stored by the inner
range:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">G</span><span class="o">&gt;</span>
<span class="k">using</span><span class="w"> </span><span class="n">inner_range</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">ranges</span><span class="o">::</span><span class="n">range_value_t</span><span class="o">&lt;</span><span class="n">G</span><span class="o">&gt;</span><span class="p">;</span>
<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">G</span><span class="o">&gt;</span>
<span class="k">using</span><span class="w"> </span><span class="n">inner_value</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">ranges</span><span class="o">::</span><span class="n">range_value_t</span><span class="o">&lt;</span><span class="n">inner_range</span><span class="o">&lt;</span><span class="n">G</span><span class="o">&gt;&gt;</span><span class="p">;</span>
</pre></div>
</div>
<p>Now we can define the concept that captures the requirements from the
lifted <code class="docutils literal notranslate"><span class="pre">bfs</span></code> and <code class="docutils literal notranslate"><span class="pre">dijkstra</span></code>:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">G</span><span class="o">&gt;</span>
<span class="k">concept</span><span class="w"> </span><span class="nc">adjacency_list</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">graph</span><span class="o">&lt;</span><span class="n">G</span><span class="o">&gt;</span>
<span class="w">    </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">ranges</span><span class="o">::</span><span class="n">random_access_range</span><span class="o">&lt;</span><span class="n">G</span><span class="o">&gt;</span>
<span class="w">    </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">ranges</span><span class="o">::</span><span class="n">forward_range</span><span class="o">&lt;</span><span class="n">inner_range_t</span><span class="o">&lt;</span><span class="n">G</span><span class="o">&gt;&gt;</span>
<span class="w">    </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">convertible_to</span><span class="o">&lt;</span><span class="n">vertex_id_t</span><span class="o">&lt;</span><span class="n">G</span><span class="o">&gt;</span><span class="p">,</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">ranges</span><span class="o">::</span><span class="n">range_difference_t</span><span class="o">&lt;</span><span class="n">G</span><span class="o">&gt;&gt;</span>
<span class="w">    </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="k">requires</span><span class="p">(</span><span class="n">G</span><span class="w"> </span><span class="n">g</span><span class="p">,</span><span class="w"> </span><span class="n">vertex_id_t</span><span class="o">&lt;</span><span class="n">G</span><span class="o">&gt;</span><span class="w"> </span><span class="n">u</span><span class="p">,</span><span class="w"> </span><span class="n">inner_value_t</span><span class="o">&lt;</span><span class="n">G</span><span class="o">&gt;</span><span class="w"> </span><span class="n">e</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="p">{</span><span class="w"> </span><span class="n">g</span><span class="p">[</span><span class="n">u</span><span class="p">]</span><span class="w"> </span><span class="p">}</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">convertible_to</span><span class="o">&lt;</span><span class="n">inner_range_t</span><span class="o">&lt;</span><span class="n">G</span><span class="o">&gt;&gt;</span><span class="p">;</span>
<span class="w">  </span><span class="p">{</span><span class="w"> </span><span class="n">target</span><span class="p">(</span><span class="n">g</span><span class="p">,</span><span class="w"> </span><span class="n">e</span><span class="p">)</span><span class="w"> </span><span class="p">}</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">convertible_to</span><span class="o">&lt;</span><span class="n">vertex_id_t</span><span class="o">&lt;</span><span class="n">G</span><span class="o">&gt;&gt;</span><span class="p">;</span><span class="w"> </span><span class="p">};</span>
</pre></div>
</div>
<p>Although we restricted our illustration of lifting to <code class="docutils literal notranslate"><span class="pre">bfs</span></code> and
<code class="docutils literal notranslate"><span class="pre">dijkstra</span></code> in this paper, this concept applies to almost all of the
algorithms in NWGraph (and, since it represents an adjacency list, we
expect it could apply to the majority of, if not all, graph algorithms
based on adjacency lists).</p>
<p>We can use this concept to constrain the interface to <code class="docutils literal notranslate"><span class="pre">bfs</span></code> in the
following two ways:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">class</span><span class="w"> </span><span class="nc">Graph</span><span class="o">&gt;</span>
<span class="k">requires</span><span class="w"> </span><span class="n">adjacency_list</span><span class="o">&lt;</span><span class="n">Graph</span><span class="o">&gt;</span>
<span class="kt">void</span><span class="w"> </span><span class="n">bfs</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">Graph</span><span class="o">&amp;</span><span class="w"> </span><span class="n">G</span><span class="p">);</span>
</pre></div>
</div>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="n">adjacency_list</span><span class="w"> </span><span class="n">Graph</span><span class="o">&gt;</span>
<span class="kt">void</span><span class="w"> </span><span class="n">bfs</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">Graph</span><span class="o">&amp;</span><span class="w"> </span><span class="n">G</span><span class="p">);</span>
</pre></div>
</div>
<p>Generally there is a fully general declaration when using concepts via
the <code class="docutils literal notranslate"><span class="pre">requires</span></code> keyword, and a number of abbreviated forms. In the
NWGraph library, the second syntax above is preferred.</p>
<section id="lifting-edge-weight">
<h3>Lifting Edge Weight<a class="headerlink" href="#lifting-edge-weight" title="Link to this heading"></a></h3>
<p>In the concrete implementation of Dijkstra’s algorithm shown above, we
assumed the container associated with each vertex in the graph (i.e.,
the container obtained by <code class="docutils literal notranslate"><span class="pre">G[u]</span></code>) provided tuples containing the
vertex id and the edge weight. In fact, there are numerous ways to
associate a weight with each edge. We could, for example, store an edge
index with each neighbor and use that to index into an array that we
also pass into <code class="docutils literal notranslate"><span class="pre">dijkstra</span></code>. In such a case the (unconstrained)
prototype for the algorithm might be</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">class</span><span class="w"> </span><span class="nc">Graph</span><span class="p">,</span><span class="w"> </span><span class="k">class</span><span class="w"> </span><span class="nc">Range</span><span class="o">&gt;</span>
<span class="k">auto</span><span class="w"> </span><span class="n">dijkstra</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">Graph</span><span class="o">&amp;</span><span class="w"> </span><span class="n">G</span><span class="p">,</span><span class="w"> </span><span class="n">vertex_id_t</span><span class="o">&lt;</span><span class="n">Graph</span><span class="o">&gt;</span><span class="w"> </span><span class="n">s</span><span class="p">,</span><span class="w"> </span><span class="n">Range</span><span class="w"> </span><span class="n">wt</span><span class="p">);</span>
</pre></div>
</div>
<p>The inner loop might then look like</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="k">auto</span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">e</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">G</span><span class="p">[</span><span class="n">u</span><span class="p">])</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">auto</span><span class="w"> </span><span class="n">v</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">target</span><span class="p">(</span><span class="n">e</span><span class="p">);</span>
<span class="w">  </span><span class="k">auto</span><span class="w"> </span><span class="n">w</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">wt</span><span class="p">[</span><span class="n">v</span><span class="p">];</span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">d</span><span class="p">[</span><span class="n">u</span><span class="p">]</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">w</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">d</span><span class="p">[</span><span class="n">v</span><span class="p">])</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">d</span><span class="p">[</span><span class="n">v</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">d</span><span class="p">[</span><span class="n">u</span><span class="p">]</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">w</span><span class="p">;</span>
<span class="w">    </span><span class="n">pi</span><span class="p">[</span><span class="n">v</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">u</span><span class="p">;</span><span class="w">          </span><span class="p">}}</span>
</pre></div>
</div>
<p>To lift this version and the version with the directly-stored property
on edges, we introduce a <code class="docutils literal notranslate"><span class="pre">weights</span></code> callable WeighFunction as a
parameter at the interface of <code class="docutils literal notranslate"><span class="pre">dijkstra</span></code>, using concepts to ensure
that the function meets the required use.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="n">adjacency_list</span><span class="w"> </span><span class="n">Graph</span><span class="p">,</span><span class="w"> </span><span class="k">class</span><span class="w"> </span><span class="nc">WeightFunction</span><span class="o">&gt;</span>
<span class="k">auto</span><span class="w"> </span><span class="n">dijkstra</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">Graph</span><span class="o">&amp;</span><span class="w"> </span><span class="n">G</span><span class="p">,</span><span class="w"> </span><span class="n">vertex_id_t</span><span class="o">&lt;</span><span class="n">Graph</span><span class="o">&gt;</span><span class="w"> </span><span class="n">s</span><span class="p">,</span><span class="w"> </span><span class="n">WeightFunction</span><span class="w"> </span><span class="n">wt</span><span class="p">);</span>
</pre></div>
</div>
<p>In this case, the inner loop would look like</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="k">auto</span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">e</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">G</span><span class="p">[</span><span class="n">u</span><span class="p">])</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">auto</span><span class="w"> </span><span class="n">v</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">target</span><span class="p">(</span><span class="n">e</span><span class="p">);</span>
<span class="w">  </span><span class="k">auto</span><span class="w"> </span><span class="n">w</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">wt</span><span class="p">(</span><span class="n">e</span><span class="p">);</span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">d</span><span class="p">[</span><span class="n">u</span><span class="p">]</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">w</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">d</span><span class="p">[</span><span class="n">v</span><span class="p">])</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">d</span><span class="p">[</span><span class="n">v</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">d</span><span class="p">[</span><span class="n">u</span><span class="p">]</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">w</span><span class="p">;</span>
<span class="w">    </span><span class="n">pi</span><span class="p">[</span><span class="n">v</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">u</span><span class="p">;</span><span class="w">          </span><span class="p">}}</span>
</pre></div>
</div>
</section>
<section id="non-type-constraints">
<h3>Non-Type Constraints<a class="headerlink" href="#non-type-constraints" title="Link to this heading"></a></h3>
<p>We have already seen in lifting the edge weight that not all constraints
for an algorithm are encapsulated in the type requirements for the input
graph. There are other requirements that an algorithm may have that
cannot be captured as a type requirement, or as any compile-time
checkable requirement. For example, some algorithms, such as triangle
counting, may require that the edges within each neighborhood be sorted.
Or, as we have seen, directedness of a graph is not a type property, but
rather a runtime property. Such requirements become part of the
specification of the API, but cannot be made part of type checking. This
is similar to, say, <code class="docutils literal notranslate"><span class="pre">binary_search</span></code> in the C++ standard library, which
requires that the elements of the container to which it is applied be
sorted. Yet, there is no such thing as a sorted container type in the
standard library.</p>
</section>
</section>
<section id="other-concepts">
<h2>Other Concepts<a class="headerlink" href="#other-concepts" title="Link to this heading"></a></h2>
<p>So far we have developed a single concept (<code class="docutils literal notranslate"><span class="pre">adjacency_list</span></code>) and the
reader may ask how broad that concept is, given the wide variety of
potential graph algorithms. In fact, <code class="docutils literal notranslate"><span class="pre">adjacency_list</span></code> concept is
surprisingly broad in its applicability; only a few supplemental
concepts are required to cover all of the algorithms implemented in
NWGraph and, based on our analysis of the comprehensive Boost Graph
Library:cite:<cite>Siek_Lee_Lumsdaine_2002</cite>, probably all of the
algorithms that are likely to be implemented in NWGraph in the future.
This is perhaps not so surprising since the adjacency list
<span class="math notranslate nohighlight">\(Adj(G)\)</span> is also the primary theoretical construct upon which the
majority of graph algorithms are built.</p>
<p>There are two additional concepts that we introduce briefly here which
we found necessary for algorithms in NWGraph: <code class="docutils literal notranslate"><span class="pre">degree_enumerable</span></code> and
<code class="docutils literal notranslate"><span class="pre">edge_list</span></code>. The former extends <code class="docutils literal notranslate"><span class="pre">adjacency_list</span></code> with the
requirement that there be a valid expession <code class="docutils literal notranslate"><span class="pre">degree</span></code>, necessary in
some algorithms. The latter is basically a container of objects for
which <code class="docutils literal notranslate"><span class="pre">source</span></code> and <code class="docutils literal notranslate"><span class="pre">target</span></code> are valid expressions. Algorithms such
as Bellman-Ford and Kruskal’s MST use an edge list rather and adjacency
list:cite:<cite>Cormen_2009</cite>.</p>
<p>Our confidence that these concepts are sufficient is based on an
extensive study of the concepts in the Boost Graph
Library:cite:<cite>Siek_Lee_Lumsdaine_2002</cite>. The Boost Graph
Library (BGL) has five essential concepts that cover all of its
algorithms: <code class="docutils literal notranslate"><span class="pre">VertexListGraph</span></code>, <code class="docutils literal notranslate"><span class="pre">EdgeListGraph</span></code>, <code class="docutils literal notranslate"><span class="pre">AdjacencyGraph</span></code>,
<code class="docutils literal notranslate"><span class="pre">IncidenceGraph</span></code>, and <code class="docutils literal notranslate"><span class="pre">BiIncidenceGraph</span></code>. Of these, the design
decisions of NWGraph to require vertex identifiers to be indices
obviates <code class="docutils literal notranslate"><span class="pre">VertexListGraph</span></code>. We don’t need to iterate through a list of
vertices provided by the graph. The NWgraph <code class="docutils literal notranslate"><span class="pre">adjacency_list</span></code> and
<code class="docutils literal notranslate"><span class="pre">degree_enumerable</span></code> concepts subsume the essential functionality of
<code class="docutils literal notranslate"><span class="pre">AdjacencyGraph</span></code> and <code class="docutils literal notranslate"><span class="pre">IncidenceGraph</span></code>. <code class="docutils literal notranslate"><span class="pre">adjacency_list</span></code> does not
have a <code class="docutils literal notranslate"><span class="pre">source</span></code> function requirement, but that is in fact only rarely
used in the BGL algorithms requiring <code class="docutils literal notranslate"><span class="pre">IncidenceGraph</span></code> (and when it is
used, there are other ways of obtaining the same information). The
<code class="docutils literal notranslate"><span class="pre">BiIncidenceGraph</span></code> concept is essentially a composite of a graph and
its transpose. This is obviated in the NWGraph design. Algorithms
requiring a graph and its transpose take them as two arguments rather
than one (there is no data that can be shared between a graph and its
transpose, so there is no loss of efficiency in that design decision).
Finally, the NWgraph <code class="docutils literal notranslate"><span class="pre">edge_list</span></code> concept is essentially identical to
the BGL <code class="docutils literal notranslate"><span class="pre">EdgeListGraph</span></code> concept.</p>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="generic-programming.html" class="btn btn-neutral float-left" title="Generic Programming in C++20" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="algorithms.html" class="btn btn-neutral float-right" title="NWGraph Algorithms" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2020-2022, PNNL, UW.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>