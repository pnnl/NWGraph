

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../">
<head>
  <meta charset="utf-8" /><meta name="viewport" content="width=device-width, initial-scale=1" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Performance Evaluation &mdash; NW Graph 0.10.15 documentation</title>
      <link rel="stylesheet" type="text/css" href="../_static/pygments.css?v=649a27d8" />
      <link rel="stylesheet" type="text/css" href="../_static/css/theme.css?v=9edc463e" />
      <link rel="stylesheet" type="text/css" href="../_static/graphviz.css?v=4ae1632d" />
      <link rel="stylesheet" type="text/css" href="../_static/collapsible-lists/css/tree_view.css?v=a885cde7" />
      <link rel="stylesheet" type="text/css" href="../_static/css/custom.css?v=afbbf639" />

  
      <script src="../_static/jquery.js?v=5d32c60e"></script>
      <script src="../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="../_static/documentation_options.js?v=a8af70a8"></script>
      <script src="../_static/doctools.js?v=fd6eb6e6"></script>
      <script src="../_static/sphinx_highlight.js?v=6ffebe34"></script>
      <script src="../_static/collapsible-lists/js/CollapsibleLists.compressed.js?v=73120307"></script>
      <script src="../_static/collapsible-lists/js/apply-collapsible-lists.js?v=660e4f45"></script>
      <script>window.MathJax = {"TeX": {"Macros": {"RR": "{\\mathbb R}", "Real": "{\\mathbb R}", "Complex": "{\\mathbb C}", "mat": ["{\\mathbf{#1}}", 1], "vec": ["{\\mathbf{#1}}", 1], "bold": ["{\\bf #1}", 1], "Spc": ["\\mathbb{#1}", 1], "norm": ["|| #1 ||", 1]}}}</script>
      <script defer="defer" src="https://cdn.jsdelivr.net/npm/mathjax@4/tex-mml-chtml.js"></script>
    <script src="../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Related Libraries and Toolkits" href="related.html" />
    <link rel="prev" title="Model Data Structures" href="data-structures.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../index.html" class="icon icon-home">
            NW Graph
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="getting_started.html">Quickstart</a></li>
<li class="toctree-l1"><a class="reference internal" href="benchmarking.html">Benchmarking with NWGraph</a></li>
<li class="toctree-l1"><a class="reference internal" href="introduction.html">NWGraph: The Northwest Graph Library</a></li>
<li class="toctree-l1"><a class="reference internal" href="graph-background-ii.html">Graph Background</a></li>
<li class="toctree-l1"><a class="reference internal" href="generic-programming.html">Generic Programming in C++20</a></li>
<li class="toctree-l1"><a class="reference internal" href="graph-concepts.html">Generic Graph Algorithms</a></li>
<li class="toctree-l1"><a class="reference internal" href="algorithms.html">NWGraph Algorithms</a></li>
<li class="toctree-l1"><a class="reference internal" href="adaptors.html">Graph Range Adaptors</a></li>
<li class="toctree-l1"><a class="reference internal" href="data-structures.html">Model Data Structures</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Performance Evaluation</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#experimental-setup">Experimental Setup</a></li>
<li class="toctree-l2"><a class="reference internal" href="#abstraction-penalty">Abstraction Penalty</a></li>
<li class="toctree-l2"><a class="reference internal" href="#performance-on-large-scale-graphs">Performance on Large-Scale Graphs</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="related.html">Related Libraries and Toolkits</a></li>
<li class="toctree-l1"><a class="reference internal" href="references.html">References Cited</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../examples/index.html">Examples</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../nwgraph_api.html">NWGraph API Reference</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">NW Graph</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../index.html" class="icon icon-home" aria-label="Home"></a></li>
      <li class="breadcrumb-item active">Performance Evaluation</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../_sources/userguide/performance.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="performance-evaluation">
<span id="sec-exp-evaluation"></span><h1>Performance Evaluation<a class="headerlink" href="#performance-evaluation" title="Link to this heading"></a></h1>
<p>In this section, we discuss our experimental results. First we evaluate
the abstraction penalty for different ways of iterating over a graph as
a range of ranges. Next we evaluate the abstraction penalty for
representing a graph with different data structures. Finally, we compare
the performance of our NWGraph library with 3 other well-known graph
frameworks: GAP graph benchmark suite <span id="id1">[<a class="reference internal" href="references.html#id31" title="Scott Beamer, Krste Asanović, and David Patterson. The GAP Benchmark Suite. arXiv preprint arXiv:1508.03919, 2015.">BAsanovicP15</a>]</span>, Galois
<span id="id2">[<a class="reference internal" href="references.html#id32" title="Milind Kulkarni, Keshav Pingali, Bruce Walter, Ganesh Ramanarayanan, Kavita Bala, and L. Paul Chew. Optimistic parallelism requires abstractions. In PLDI, 211–222. ACM, 2007. URL: https://doi.org/10.1145/1250734.1250759, doi:10.1145/1250734.1250759.">KPW+07</a>]</span> graph library and GraphIt</p>
<blockquote>
<div><p><span id="id3">[<a class="reference internal" href="references.html#id33" title="Yunming Zhang, Mengjiao Yang, Riyadh Baghdadi, Shoaib Kamil, Julian Shun, and Saman Amarasinghe. GraphIt: A high-performance graph DSL. PACMPL/OOPSLA, 2:121:1–121:30, October 2018.">ZYB+18</a>]</span> domain-specific language for graphs.</p>
</div></blockquote>
<section id="experimental-setup">
<h2>Experimental Setup<a class="headerlink" href="#experimental-setup" title="Link to this heading"></a></h2>
<p>Abstraction penalty benchmarks were run on 2019 MacBook Pro with 2.4 GHz
8-Core Intel® Core i9 processor with 64 GB DDR4 memory running at
2.6GHz. All performance measurements were collected on Intel® Xeon®
-based servers. Each server contains two Intel® Xeon® Platinum 8153
processors, each with 16 physical cores (32 logical cores) running at
2.0 GHz. Each processor has 22 MB L3 cache. The total system memory of
each server is 384 GB DDR4 running at 2.6 GHz. We used GCC 10 with
“-Ofast” and TBB 2020.3 to compile.</p>
<div class="figure docutils container">
<figure class="align-default" id="fig-abp-spmv">
<img alt="Different data access abstractions (``iterator``\ s, ``range``\ s, ``std::for_each`` and ``neighbor_range`` adaptor) with their abstraction penalties measured relative to a raw for loop implementation. There is no significant performance penalty relative to the raw loop implementation." src="../_images/abp-spmv-intel.pdf" />
<figcaption>
<p><span class="caption-number">Fig. 6 </span><span class="caption-text">Different data access abstractions (<code class="docutils literal notranslate"><span class="pre">iterator</span></code>s, <code class="docutils literal notranslate"><span class="pre">range</span></code>s,
<code class="docutils literal notranslate"><span class="pre">std::for_each</span></code> and <code class="docutils literal notranslate"><span class="pre">neighbor_range</span></code> adaptor) with their
abstraction penalties measured relative to a raw for loop
implementation. There is no significant performance penalty
relative to the raw loop implementation.</span><a class="headerlink" href="#fig-abp-spmv" title="Link to this image"></a></p>
</figcaption>
</figure>
<figure class="align-default" id="fig-abp-containers">
<img alt="Measured abstraction penalty for the SpMV benchmark with graphs represented by different containers using ``iterator`` based ``for`` loop. The execution time has been normalized w.r.t to the execution time of SpMV with graphs represented as ``struct_of_array`` (lower is better)." src="../_images/abp-containers-intel.pdf" />
<figcaption>
<p><span class="caption-number">Fig. 7 </span><span class="caption-text">Measured abstraction penalty for the SpMV benchmark with graphs
represented by different containers using <code class="docutils literal notranslate"><span class="pre">iterator</span></code> based
<code class="docutils literal notranslate"><span class="pre">for</span></code> loop. The execution time has been normalized w.r.t to the
execution time of SpMV with graphs represented as
<code class="docutils literal notranslate"><span class="pre">struct_of_array</span></code> (lower is better).</span><a class="headerlink" href="#fig-abp-containers" title="Link to this image"></a></p>
</figcaption>
</figure>
</div>
</section>
<section id="abstraction-penalty">
<span id="sec-abp-results"></span><h2>Abstraction Penalty<a class="headerlink" href="#abstraction-penalty" title="Link to this heading"></a></h2>
<p>Using a range-based interface introduces a variety of different ways to
iterate through a graph (including the use of graph adaptors). While
ranges and range based for loops are useful programming abstractions, it
is important to consider any performance abstraction penalties
associated with their use. We benchmark these penalties to ensure they
will not significantly limit performance compared to a “raw for loop”
implementation. For example let us consider the sparse matrix-dense
vector multiplication (SpMV) kernel used in page rank, which multiplies
the adjacency matrix representation of a graph by a dense vector
<span class="math notranslate nohighlight">\(x\)</span> and stores the result in another vector <span class="math notranslate nohighlight">\(y\)</span>. Using a
compressed sparse row (CSR) data structure to store the adjacency
matrix, a raw for loop implementation would access the indices and
weights of edges with pointers into the CSR data structure.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// Raw for loop SpMV</span>
<span class="k">auto</span><span class="w"> </span><span class="n">ptr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">G</span><span class="p">.</span><span class="n">indices_</span><span class="p">.</span><span class="n">data</span><span class="p">();</span>
<span class="k">auto</span><span class="w"> </span><span class="n">idx</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">get</span><span class="o">&lt;</span><span class="mi">0</span><span class="o">&gt;</span><span class="p">(</span><span class="n">G</span><span class="p">.</span><span class="n">to_be_indexed_</span><span class="p">).</span><span class="n">data</span><span class="p">();</span>
<span class="k">auto</span><span class="w"> </span><span class="n">dat</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">get</span><span class="o">&lt;</span><span class="mi">1</span><span class="o">&gt;</span><span class="p">(</span><span class="n">G</span><span class="p">.</span><span class="n">to_be_indexed_</span><span class="p">).</span><span class="n">data</span><span class="p">();</span>
<span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">vertex_id_t</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">N</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="k">auto</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ptr</span><span class="p">[</span><span class="n">i</span><span class="p">];</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">ptr</span><span class="p">[</span><span class="n">i</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">];</span><span class="w"> </span><span class="o">++</span><span class="n">j</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">y</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">x</span><span class="p">[</span><span class="n">idx</span><span class="p">[</span><span class="n">j</span><span class="p">]]</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">dat</span><span class="p">[</span><span class="n">j</span><span class="p">];</span><span class="w"> </span><span class="p">}}</span>
</pre></div>
</div>
<p>However NWGraph does not assume this underlying CSR structure, and would
prefer to write these algorithms more generically with iterator based or
range based for loops shown below. Note that the previous raw loop
implementation had access to information that the SpMV kernel does not
actually need, which is random access into a vertex’s incidence list.
The incidence list only needs to be traversed in some order to produce
the desired result.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// Iterator based for loop SpMV</span>
<span class="n">vertex_id_t</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="k">auto</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">G</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">G</span><span class="p">.</span><span class="n">end</span><span class="p">();</span><span class="w"> </span><span class="o">++</span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="k">auto</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">i</span><span class="p">).</span><span class="n">begin</span><span class="p">();</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">i</span><span class="p">).</span><span class="n">end</span><span class="p">();</span><span class="w"> </span><span class="o">++</span><span class="n">j</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">y</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">x</span><span class="p">[</span><span class="n">get</span><span class="o">&lt;</span><span class="mi">0</span><span class="o">&gt;</span><span class="p">(</span><span class="o">*</span><span class="n">j</span><span class="p">)]</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">get</span><span class="o">&lt;</span><span class="mi">1</span><span class="o">&gt;</span><span class="p">(</span><span class="o">*</span><span class="n">j</span><span class="p">);</span><span class="w"> </span><span class="p">}</span>
<span class="w">  </span><span class="o">++</span><span class="n">k</span><span class="p">;</span><span class="w"> </span><span class="p">}</span>
<span class="c1">// Range based for loop SpMV</span>
<span class="n">vertex_id_t</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="k">auto</span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">G</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="k">auto</span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="p">[</span><span class="n">j</span><span class="p">,</span><span class="w"> </span><span class="n">v</span><span class="p">]</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">y</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">x</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">v</span><span class="p">;</span><span class="w"> </span><span class="p">}</span>
<span class="w">  </span><span class="o">++</span><span class="n">k</span><span class="p">;</span><span class="w"> </span><span class="p">}</span>
</pre></div>
</div>
<p>Iterators can also be used to process the edges with <code class="docutils literal notranslate"><span class="pre">std::for_each</span></code>.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// STL for_each SpMV</span>
<span class="n">std</span><span class="o">::</span><span class="n">for_each</span><span class="p">(</span><span class="n">G</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span><span class="w"> </span><span class="n">G</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span><span class="w"> </span><span class="p">[</span><span class="o">&amp;</span><span class="p">](</span><span class="k">auto</span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">e</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">y</span><span class="p">[</span><span class="n">std</span><span class="o">::</span><span class="n">get</span><span class="o">&lt;</span><span class="mi">0</span><span class="o">&gt;</span><span class="p">(</span><span class="n">e</span><span class="p">)]</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">x</span><span class="p">[</span><span class="n">std</span><span class="o">::</span><span class="n">get</span><span class="o">&lt;</span><span class="mi">1</span><span class="o">&gt;</span><span class="p">(</span><span class="n">e</span><span class="p">)]</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">get</span><span class="o">&lt;</span><span class="mi">2</span><span class="o">&gt;</span><span class="p">(</span><span class="n">e</span><span class="p">);</span><span class="w"> </span><span class="p">});</span>
</pre></div>
</div>
<p>Finally, with one of our range adaptors, <code class="docutils literal notranslate"><span class="pre">neighbor_range</span></code>, we can
easily access the indices and the neighbors of it.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// Neighbor range based for loop (SpMV)</span>
<span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="k">auto</span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="n">neighbors</span><span class="p">]</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">neighbor_range</span><span class="p">(</span><span class="n">G</span><span class="p">))</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="k">auto</span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="p">[</span><span class="n">j</span><span class="p">,</span><span class="w"> </span><span class="n">v</span><span class="p">]</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">neighbors</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">y</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">x</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">v</span><span class="p">;</span><span class="w"> </span><span class="p">}}</span>
</pre></div>
</div>
<p>There are even more combinations of these traversals that are omitted
for lack of space (combinations of ranges and iterators, with and
without compound initializers, <code class="docutils literal notranslate"><span class="pre">auto</span></code> vs <code class="docutils literal notranslate"><span class="pre">auto&amp;&amp;</span></code> etc.).</p>
<p>To experimentally evaluate the abstraction penalty, we consider SpMV
with three graphs with different underlying topologies from the
SuiteSparse matrix collection: circuit5M, GAP-road, and hugebubbles.
These were chosen because they have similar numbers of edges (30M to
60M) and the benchmarks run in comparable time. Timing results were
averaged over 5 runs of each benchmark.   shows the results of the
different data access abstractions relative to the raw loop timing, for
each benchmark. Bars significantly higher than the raw for loop bar
would indicate a significant performance penalty. None of the
abstraction methods incurs a significant performance penalty relative to
the raw loop implementation.</p>
<p>We also evaluated the abstraction penalty incurred for storing a graph
in different containers. In particular, we have selected
<code class="docutils literal notranslate"><span class="pre">struct_of_array</span></code>, <code class="docutils literal notranslate"><span class="pre">vector_of_vector</span></code>, <code class="docutils literal notranslate"><span class="pre">vector_of_list</span></code>,
<code class="docutils literal notranslate"><span class="pre">vector_of_forward_list</span></code> containers. Note that all of these containers
meet the requirement of our <code class="docutils literal notranslate"><span class="pre">graph</span></code> concept. We consider SpMV
benchmark implemented with iterator based for loop with circuit5M,
GAP-road, and hugebubbles datasets.   shows the performance of SpMV with
different containers. The execution time is normalized relative to the
execution time of SpMV with <code class="docutils literal notranslate"><span class="pre">struct_of_array</span></code> container. As can be
observed from  , SpMV with <code class="docutils literal notranslate"><span class="pre">struct_of_array</span></code> performs best, followed
by <code class="docutils literal notranslate"><span class="pre">vector_of_vector</span></code>. <code class="docutils literal notranslate"><span class="pre">struct_of_array</span></code> representation is
cache-friendly and supports random access of the outer and inner range
efficiently.</p>
</section>
<section id="performance-on-large-scale-graphs">
<span id="sec-performance"></span><h2>Performance on Large-Scale Graphs<a class="headerlink" href="#performance-on-large-scale-graphs" title="Link to this heading"></a></h2>
<p>In addition to being generic, NWGraph is intended to be a
high-performance library and includes parallel implementations of a
number of its algorithms. Parallelization is effected using C++ standard
library execution policies and with Intel’s Threading Building Blocks
(TBB) (<span id="id4">[<a class="reference internal" href="references.html#id34" title="Intel. Intel Threading Building Blocks (TBB). 2020. URL: https://github.com/oneapi-src/oneTBB.">Intel20</a>]</span>).</p>
<p>To demonstrate NWGraph’s performance on large-scale graphs, we evaluate
and compare the performance of NWGraph with three well-known graph
frameworks: GAP <span id="id5">[<a class="reference internal" href="references.html#id31" title="Scott Beamer, Krste Asanović, and David Patterson. The GAP Benchmark Suite. arXiv preprint arXiv:1508.03919, 2015.">BAsanovicP15</a>]</span>,
Galois <span id="id6">[]</span> and
GraphIt <span id="id7">[<a class="reference internal" href="references.html#id33" title="Yunming Zhang, Mengjiao Yang, Riyadh Baghdadi, Shoaib Kamil, Julian Shun, and Saman Amarasinghe. GraphIt: A high-performance graph DSL. PACMPL/OOPSLA, 2:121:1–121:30, October 2018.">ZYB+18</a>]</span>. The evaluation is intended to
assess the performance of various parallel graph algorithms available in
NWGraph in the context of other HPC graph frameworks. Since BGL is
single-threaded, we did not include it for comparison. Overall, NWGraph
leverages TBB concurrent data structures for maintaining the internal
states of different graph algorithms. In addition, for workload
distribution among the threads, NWGraph can either use <code class="docutils literal notranslate"><span class="pre">block</span></code> range
from TBB, our customized <code class="docutils literal notranslate"><span class="pre">cyclic</span></code> range adaptor, or C++ parallel
execution policy (<code class="docutils literal notranslate"><span class="pre">std::execution::par</span></code>,
<code class="docutils literal notranslate"><span class="pre">std::execution::par_unseq</span></code>) whenever appropriate. All experiments are
conducted on 32 physical cores.</p>
<p>For our experiments, we chose five representative datasets according to
the GAP benchmark suite (<span id="id8">[<a class="reference internal" href="references.html#id31" title="Scott Beamer, Krste Asanović, and David Patterson. The GAP Benchmark Suite. arXiv preprint arXiv:1508.03919, 2015.">BAsanovicP15</a>]</span>). These datasets ()
have diverse structural properties and have been collected from various
application domains. We select six different graph algorithms
(Betweenness Centrality, Breadth-first Search, Connected Components,
Page Rank, Single Source Shortest Path, and Triangle Counting) that are
common across these graph frameworks.</p>
<div class="figure docutils container">
<figure class="align-default">
<img alt="../_images/BC_perf.pdf" src="../_images/BC_perf.pdf" />
</figure>
<figure class="align-default">
<img alt="../_images/BFS_perf.pdf" src="../_images/BFS_perf.pdf" />
</figure>
<figure class="align-default">
<img alt="../_images/CC_perf.pdf" src="../_images/CC_perf.pdf" />
</figure>
<figure class="align-default">
<img alt="../_images/PR_perf.pdf" src="../_images/PR_perf.pdf" />
</figure>
<figure class="align-default">
<img alt="../_images/SSSP_perf.pdf" src="../_images/SSSP_perf.pdf" />
</figure>
<figure class="align-default">
<img alt="../_images/TC_perf.pdf" src="../_images/TC_perf.pdf" />
</figure>
</div>
<p>The performance of different graph frameworks is shown above . We
summarize our observations as follows:</p>
<ul class="simple">
<li><p>With Web and kron datasets, which have skewed degree distribution,
our triangle counting (TC) and Gauss-Seidel page rank algorithms in
NWGraph outperform other frameworks. Except for the road network
input, for both of these graph problems, NWGraph performs comparably
with other inputs. The performance of NWGraph can be attributed to
the cyclic range adaptor, which helps to achieve better load balance
among the threads for graphs with skewed degree distribution. TC also
includes pre-processing techniques such as relabeling the vertices by
degree (the pre-processing time is included in the reported
normalized execution time).</p></li>
<li><p>NWGraph also runs faster with Web, Twitter and Kron datasets
(power-law graphs) for Betweenness Centrality (BC) algorithms.</p></li>
<li><p>NWGraph suffers performance with bounded graphs such as road network
input for SSSP due to limited parallelism available and due to the
uniform degree distribution in these types of graphs. Overall,
NWGraph performs better or comparable to other graph frameworks.</p></li>
<li><p>For connected component (CC), all frameworks except GraphIt implement
Afforest algorithm <span id="id9">[<a class="reference internal" href="references.html#id16" title="Michael Sutton, Tal Ben-Nun, and Amnon Barak. Optimizing parallel graph connectivity computation via subgraph sampling. In IPDPS, 12–21. IEEE, 2018.">SBNB18</a>]</span>. Hence GraphIt
performs worse with all inputs for CC.</p></li>
</ul>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="data-structures.html" class="btn btn-neutral float-left" title="Model Data Structures" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="related.html" class="btn btn-neutral float-right" title="Related Libraries and Toolkits" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2020-2022, PNNL, UW.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>