

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../../">
<head>
  <meta charset="utf-8" /><meta name="viewport" content="width=device-width, initial-scale=1" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Prim’s Minimum Spanning Tree Algorithm (BGL Book Chapter 6) &mdash; NW Graph 0.10.15 documentation</title>
      <link rel="stylesheet" type="text/css" href="../../_static/pygments.css?v=649a27d8" />
      <link rel="stylesheet" type="text/css" href="../../_static/css/theme.css?v=9edc463e" />
      <link rel="stylesheet" type="text/css" href="../../_static/graphviz.css?v=4ae1632d" />
      <link rel="stylesheet" type="text/css" href="../../_static/collapsible-lists/css/tree_view.css?v=a885cde7" />
      <link rel="stylesheet" type="text/css" href="../../_static/css/custom.css?v=afbbf639" />

  
      <script src="../../_static/jquery.js?v=5d32c60e"></script>
      <script src="../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="../../_static/documentation_options.js?v=a8af70a8"></script>
      <script src="../../_static/doctools.js?v=fd6eb6e6"></script>
      <script src="../../_static/sphinx_highlight.js?v=6ffebe34"></script>
      <script src="../../_static/collapsible-lists/js/CollapsibleLists.compressed.js?v=73120307"></script>
      <script src="../../_static/collapsible-lists/js/apply-collapsible-lists.js?v=660e4f45"></script>
    <script src="../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <link rel="next" title="Connected Components (BGL Book Chapter 7)" href="ch7_connected.html" />
    <link rel="prev" title="Kruskal’s Minimum Spanning Tree Algorithm (BGL Book Chapter 6)" href="ch6_kruskal.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../index.html" class="icon icon-home">
            NW Graph
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../userguide/getting_started.html">Quickstart</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../userguide/benchmarking.html">Benchmarking with NWGraph</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../userguide/introduction.html">NWGraph: The Northwest Graph Library</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../userguide/graph-background-ii.html">Graph Background</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../userguide/generic-programming.html">Generic Programming in C++20</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../userguide/graph-concepts.html">Generic Graph Algorithms</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../userguide/algorithms.html">NWGraph Algorithms</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../userguide/adaptors.html">Graph Range Adaptors</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../userguide/data-structures.html">Model Data Structures</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../userguide/performance.html">Performance Evaluation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../userguide/related.html">Related Libraries and Toolkits</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../userguide/references.html">References Cited</a></li>
</ul>
<ul class="current">
<li class="toctree-l1 current"><a class="reference internal" href="../index.html">Examples</a><ul class="current">
<li class="toctree-l2 current"><a class="reference internal" href="index.html">Boost Graph Library Examples (Rewritten for NW Graph)</a><ul class="current">
<li class="toctree-l3"><a class="reference internal" href="ch3_toposort.html">File Dependencies - Topological Sort (BGL Book Chapter 3)</a></li>
<li class="toctree-l3"><a class="reference internal" href="ch4_kevin_bacon.html">Six Degrees of Kevin Bacon (BGL Book Chapter 4.1)</a></li>
<li class="toctree-l3"><a class="reference internal" href="ch4_loop_detection.html">Finding Loops in Program Control-Flow Graphs (BGL Book Chapter 4.2)</a></li>
<li class="toctree-l3"><a class="reference internal" href="ch5_dijkstra.html">Internet Routing with Dijkstra’s Algorithm (BGL Book Chapter 5.4)</a></li>
<li class="toctree-l3"><a class="reference internal" href="ch5_bellman_ford.html">Bellman-Ford Algorithm and Distance Vector Routing (BGL Book Chapter 5.3)</a></li>
<li class="toctree-l3"><a class="reference internal" href="ch6_kruskal.html">Kruskal’s Minimum Spanning Tree Algorithm (BGL Book Chapter 6)</a></li>
<li class="toctree-l3 current"><a class="current reference internal" href="#">Prim’s Minimum Spanning Tree Algorithm (BGL Book Chapter 6)</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#overview">Overview</a></li>
<li class="toctree-l4"><a class="reference internal" href="#telephone-network-planning">Telephone Network Planning</a></li>
<li class="toctree-l4"><a class="reference internal" href="#prim-s-algorithm">Prim’s Algorithm</a></li>
<li class="toctree-l4"><a class="reference internal" href="#output-format">Output Format</a></li>
<li class="toctree-l4"><a class="reference internal" href="#non-uniqueness-of-msts">Non-Uniqueness of MSTs</a></li>
<li class="toctree-l4"><a class="reference internal" href="#nwgraph-implementation">NWGraph Implementation</a></li>
<li class="toctree-l4"><a class="reference internal" href="#building-and-running-the-example">Building and Running the Example</a></li>
<li class="toctree-l4"><a class="reference internal" href="#sample-output">Sample Output</a></li>
<li class="toctree-l4"><a class="reference internal" href="#key-nwgraph-features-demonstrated">Key NWGraph Features Demonstrated</a></li>
<li class="toctree-l4"><a class="reference internal" href="#references">References</a></li>
<li class="toctree-l4"><a class="reference internal" href="#see-also">See Also</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="ch7_connected.html">Connected Components (BGL Book Chapter 7)</a></li>
<li class="toctree-l3"><a class="reference internal" href="ch7_strongly_connected.html">Strongly Connected Components and Web Page Links (BGL Book Chapter 7.3)</a></li>
<li class="toctree-l3"><a class="reference internal" href="ch8_maxflow.html">Maximum Flow (BGL Book Chapter 8)</a></li>
<li class="toctree-l3"><a class="reference internal" href="ch9_knights_tour.html">Implicit Graphs: A Knight’s Tour (BGL Book Chapter 9)</a></li>
<li class="toctree-l3"><a class="reference internal" href="index.html#overview">Overview</a></li>
<li class="toctree-l3"><a class="reference internal" href="index.html#building-the-examples">Building the Examples</a></li>
<li class="toctree-l3"><a class="reference internal" href="index.html#running-the-examples">Running the Examples</a></li>
<li class="toctree-l3"><a class="reference internal" href="index.html#reference">Reference</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../degrees/index.html">Six Degrees of Separation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../imdb/index.html">IMDB Network Analysis Examples</a></li>
<li class="toctree-l2"><a class="reference internal" href="../index.html#bgl-book-examples">BGL Book Examples</a></li>
<li class="toctree-l2"><a class="reference internal" href="../index.html#six-degrees-of-separation">Six Degrees of Separation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../index.html#imdb-examples">IMDB Examples</a></li>
</ul>
</li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../nwgraph_api.html">NWGraph API Reference</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">NW Graph</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../index.html">Examples</a></li>
          <li class="breadcrumb-item"><a href="index.html">Boost Graph Library Examples (Rewritten for NW Graph)</a></li>
      <li class="breadcrumb-item active">Prim’s Minimum Spanning Tree Algorithm (BGL Book Chapter 6)</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../../_sources/examples/bglbook/ch6_prim.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="prim-s-minimum-spanning-tree-algorithm-bgl-book-chapter-6">
<h1>Prim’s Minimum Spanning Tree Algorithm (BGL Book Chapter 6)<a class="headerlink" href="#prim-s-minimum-spanning-tree-algorithm-bgl-book-chapter-6" title="Link to this heading"></a></h1>
<p><em>Based on “The Boost Graph Library” by Jeremy Siek, Lie-Quan Lee, and Andrew Lumsdaine</em></p>
<section id="overview">
<h2>Overview<a class="headerlink" href="#overview" title="Link to this heading"></a></h2>
<p>Prim’s algorithm is another classic algorithm for finding a minimum spanning tree (MST)
of an undirected weighted graph. Unlike Kruskal’s algorithm which works edge by edge,
Prim’s algorithm grows the MST one <strong>vertex</strong> at a time.</p>
</section>
<section id="telephone-network-planning">
<h2>Telephone Network Planning<a class="headerlink" href="#telephone-network-planning" title="Link to this heading"></a></h2>
<p>This example applies Prim’s algorithm to the same telephone network planning problem
as in the Kruskal example. The goal is to find the minimum cost way to connect all
towns in a region using existing roads.</p>
</section>
<section id="prim-s-algorithm">
<h2>Prim’s Algorithm<a class="headerlink" href="#prim-s-algorithm" title="Link to this heading"></a></h2>
<p>Prim’s algorithm grows the minimum spanning tree one vertex at a time. The basic idea
is to add vertices to the MST based on which of the remaining vertices shares an edge
having minimum weight with any of the vertices already in the tree.</p>
<p>The algorithm proceeds as follows:</p>
<ol class="arabic simple">
<li><p>Start with an arbitrary vertex as the initial tree</p></li>
<li><p>Find the minimum weight edge connecting a vertex in the tree to a vertex outside</p></li>
<li><p>Add that edge and vertex to the tree</p></li>
<li><p>Repeat until all vertices are in the tree</p></li>
</ol>
<section id="relationship-to-dijkstra-s-algorithm">
<h3>Relationship to Dijkstra’s Algorithm<a class="headerlink" href="#relationship-to-dijkstra-s-algorithm" title="Link to this heading"></a></h3>
<p>Prim’s algorithm is remarkably similar to Dijkstra’s shortest-paths algorithm. In fact,
the BGL implementation of Prim’s algorithm is simply a call to Dijkstra’s algorithm,
with a special choice for the distance comparison and combine functions.</p>
<p>The key difference:</p>
<ul class="simple">
<li><p><strong>Dijkstra</strong>: <code class="docutils literal notranslate"><span class="pre">d[v]</span> <span class="pre">=</span> <span class="pre">min(d[u]</span> <span class="pre">+</span> <span class="pre">w(u,v),</span> <span class="pre">d[v])</span></code> (accumulate path weight)</p></li>
<li><p><strong>Prim</strong>: <code class="docutils literal notranslate"><span class="pre">d[v]</span> <span class="pre">=</span> <span class="pre">min(w(u,v),</span> <span class="pre">d[v])</span></code> (only consider edge weight)</p></li>
</ul>
</section>
</section>
<section id="output-format">
<h2>Output Format<a class="headerlink" href="#output-format" title="Link to this heading"></a></h2>
<p>Prim’s algorithm outputs the MST as a <strong>predecessor map</strong>. For each vertex v in the
graph, <code class="docutils literal notranslate"><span class="pre">parent[v]</span></code> is the parent of v in the minimum spanning tree. This representation
is more compact than storing edges explicitly.</p>
<p>If <code class="docutils literal notranslate"><span class="pre">parent[v]</span> <span class="pre">==</span> <span class="pre">v</span></code>, then either v is the root of the tree or it was not in the same
connected component as the rest of the vertices.</p>
</section>
<section id="non-uniqueness-of-msts">
<h2>Non-Uniqueness of MSTs<a class="headerlink" href="#non-uniqueness-of-msts" title="Link to this heading"></a></h2>
<p>Note that the MST produced by Prim’s algorithm may be slightly different from the one
produced by Kruskal’s algorithm when multiple edges have the same weight. This
highlights the fact that minimum spanning trees are not unique; there can be more than
one MST for a particular graph (though they all have the same total weight).</p>
</section>
<section id="nwgraph-implementation">
<h2>NWGraph Implementation<a class="headerlink" href="#nwgraph-implementation" title="Link to this heading"></a></h2>
<p>NWGraph provides a <code class="docutils literal notranslate"><span class="pre">prim</span></code> function that implements Prim’s algorithm using a priority
queue to efficiently select the minimum weight edge.</p>
<div class="literal-block-wrapper docutils container" id="id1">
<div class="code-block-caption"><span class="caption-number">Listing 7 </span><span class="caption-text">Complete source code</span><a class="headerlink" href="#id1" title="Link to this code"></a></div>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="linenos">  1</span><span class="cm">/**</span>
<span class="linenos">  2</span><span class="cm"> * @file ch6_prim.cpp</span>
<span class="linenos">  3</span><span class="cm"> *</span>
<span class="linenos">  4</span><span class="cm"> * @brief Prim&#39;s Minimum Spanning Tree Algorithm (BGL Book Chapter 6)</span>
<span class="linenos">  5</span><span class="cm"> *</span>
<span class="linenos">  6</span><span class="cm"> * This example demonstrates Prim&#39;s algorithm for finding a minimum spanning</span>
<span class="linenos">  7</span><span class="cm"> * tree of an undirected weighted graph. Unlike Kruskal&#39;s algorithm which</span>
<span class="linenos">  8</span><span class="cm"> * works with edges, Prim&#39;s algorithm grows the MST from a starting vertex.</span>
<span class="linenos">  9</span><span class="cm"> *</span>
<span class="linenos"> 10</span><span class="cm"> * Both algorithms produce the same MST (or one of equal weight if there</span>
<span class="linenos"> 11</span><span class="cm"> * are ties), but Prim&#39;s is often more efficient for dense graphs.</span>
<span class="linenos"> 12</span><span class="cm"> *</span>
<span class="linenos"> 13</span><span class="cm"> * @copyright SPDX-FileCopyrightText: 2022 Battelle Memorial Institute</span>
<span class="linenos"> 14</span><span class="cm"> * @copyright SPDX-FileCopyrightText: 2022 University of Washington</span>
<span class="linenos"> 15</span><span class="cm"> *</span>
<span class="linenos"> 16</span><span class="cm"> * SPDX-License-Identifier: BSD-3-Clause</span>
<span class="linenos"> 17</span><span class="cm"> *</span>
<span class="linenos"> 18</span><span class="cm"> * @authors</span>
<span class="linenos"> 19</span><span class="cm"> *   Andrew Lumsdaine</span>
<span class="linenos"> 20</span><span class="cm"> *</span>
<span class="linenos"> 21</span><span class="cm"> */</span>
<span class="linenos"> 22</span>
<span class="linenos"> 23</span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;iostream&gt;</span>
<span class="linenos"> 24</span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;limits&gt;</span>
<span class="linenos"> 25</span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;queue&gt;</span>
<span class="linenos"> 26</span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;vector&gt;</span>
<span class="linenos"> 27</span>
<span class="linenos"> 28</span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;nwgraph/adjacency.hpp&quot;</span>
<span class="linenos"> 29</span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;nwgraph/edge_list.hpp&quot;</span>
<span class="linenos"> 30</span>
<span class="linenos"> 31</span><span class="k">using</span><span class="w"> </span><span class="k">namespace</span><span class="w"> </span><span class="nn">nw</span><span class="o">::</span><span class="nn">graph</span><span class="p">;</span>
<span class="linenos"> 32</span>
<span class="linenos"> 33</span><span class="cm">/**</span>
<span class="linenos"> 34</span><span class="cm"> * @brief Simple implementation of Prim&#39;s MST algorithm</span>
<span class="linenos"> 35</span><span class="cm"> *</span>
<span class="linenos"> 36</span><span class="cm"> * This is a straightforward implementation similar to the BGL book&#39;s approach.</span>
<span class="linenos"> 37</span><span class="cm"> * It uses a priority queue to always select the minimum weight edge connecting</span>
<span class="linenos"> 38</span><span class="cm"> * a visited vertex to an unvisited vertex.</span>
<span class="linenos"> 39</span><span class="cm"> *</span>
<span class="linenos"> 40</span><span class="cm"> * @return Vector of predecessor vertices (the MST as a parent array)</span>
<span class="linenos"> 41</span><span class="cm"> */</span>
<span class="linenos"> 42</span><span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">Graph</span><span class="p">,</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">Weight</span><span class="o">&gt;</span>
<span class="linenos"> 43</span><span class="k">auto</span><span class="w"> </span><span class="n">prim_mst</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">Graph</span><span class="o">&amp;</span><span class="w"> </span><span class="n">G</span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">source</span><span class="p">,</span><span class="w"> </span><span class="n">Weight</span><span class="w"> </span><span class="n">weight_fn</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="linenos"> 44</span><span class="w">  </span><span class="kt">size_t</span><span class="w"> </span><span class="n">N</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">G</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>
<span class="linenos"> 45</span>
<span class="linenos"> 46</span><span class="w">  </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="w"> </span><span class="n">distance</span><span class="p">(</span><span class="n">N</span><span class="p">,</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">numeric_limits</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;::</span><span class="n">max</span><span class="p">());</span>
<span class="linenos"> 47</span><span class="w">  </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">size_t</span><span class="o">&gt;</span><span class="w"> </span><span class="n">predecessor</span><span class="p">(</span><span class="n">N</span><span class="p">,</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">numeric_limits</span><span class="o">&lt;</span><span class="kt">size_t</span><span class="o">&gt;::</span><span class="n">max</span><span class="p">());</span>
<span class="linenos"> 48</span><span class="w">  </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">bool</span><span class="o">&gt;</span><span class="w"> </span><span class="n">in_mst</span><span class="p">(</span><span class="n">N</span><span class="p">,</span><span class="w"> </span><span class="nb">false</span><span class="p">);</span>
<span class="linenos"> 49</span>
<span class="linenos"> 50</span><span class="w">  </span><span class="n">distance</span><span class="p">[</span><span class="n">source</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="linenos"> 51</span>
<span class="linenos"> 52</span><span class="w">  </span><span class="c1">// Priority queue: (distance, vertex)</span>
<span class="linenos"> 53</span><span class="w">  </span><span class="k">using</span><span class="w"> </span><span class="n">pq_element</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="kt">double</span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="o">&gt;</span><span class="p">;</span>
<span class="linenos"> 54</span><span class="w">  </span><span class="n">std</span><span class="o">::</span><span class="n">priority_queue</span><span class="o">&lt;</span><span class="n">pq_element</span><span class="p">,</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">pq_element</span><span class="o">&gt;</span><span class="p">,</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">greater</span><span class="o">&lt;</span><span class="n">pq_element</span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="n">pq</span><span class="p">;</span>
<span class="linenos"> 55</span><span class="w">  </span><span class="n">pq</span><span class="p">.</span><span class="n">push</span><span class="p">({</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">source</span><span class="p">});</span>
<span class="linenos"> 56</span>
<span class="linenos"> 57</span><span class="w">  </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">pq</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span><span class="w"> </span><span class="p">{</span>
<span class="linenos"> 58</span><span class="w">    </span><span class="k">auto</span><span class="w"> </span><span class="p">[</span><span class="n">d</span><span class="p">,</span><span class="w"> </span><span class="n">u</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pq</span><span class="p">.</span><span class="n">top</span><span class="p">();</span>
<span class="linenos"> 59</span><span class="w">    </span><span class="n">pq</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span>
<span class="linenos"> 60</span>
<span class="linenos"> 61</span><span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">in_mst</span><span class="p">[</span><span class="n">u</span><span class="p">])</span><span class="w"> </span><span class="k">continue</span><span class="p">;</span>
<span class="linenos"> 62</span><span class="w">    </span><span class="n">in_mst</span><span class="p">[</span><span class="n">u</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">true</span><span class="p">;</span>
<span class="linenos"> 63</span>
<span class="linenos"> 64</span><span class="w">    </span><span class="c1">// Examine all adjacent vertices</span>
<span class="linenos"> 65</span><span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="k">auto</span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">edge</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">G</span><span class="p">[</span><span class="n">u</span><span class="p">])</span><span class="w"> </span><span class="p">{</span>
<span class="linenos"> 66</span><span class="w">      </span><span class="k">auto</span><span class="w"> </span><span class="n">v</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">get</span><span class="o">&lt;</span><span class="mi">0</span><span class="o">&gt;</span><span class="p">(</span><span class="n">edge</span><span class="p">);</span>
<span class="linenos"> 67</span><span class="w">      </span><span class="k">auto</span><span class="w"> </span><span class="n">w</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">weight_fn</span><span class="p">(</span><span class="n">edge</span><span class="p">);</span>
<span class="linenos"> 68</span>
<span class="linenos"> 69</span><span class="w">      </span><span class="c1">// Key difference from Dijkstra: we compare edge weight, not total path</span>
<span class="linenos"> 70</span><span class="w">      </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">in_mst</span><span class="p">[</span><span class="n">v</span><span class="p">]</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">w</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">distance</span><span class="p">[</span><span class="n">v</span><span class="p">])</span><span class="w"> </span><span class="p">{</span>
<span class="linenos"> 71</span><span class="w">        </span><span class="n">distance</span><span class="p">[</span><span class="n">v</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">w</span><span class="p">;</span>
<span class="linenos"> 72</span><span class="w">        </span><span class="n">predecessor</span><span class="p">[</span><span class="n">v</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">u</span><span class="p">;</span>
<span class="linenos"> 73</span><span class="w">        </span><span class="n">pq</span><span class="p">.</span><span class="n">push</span><span class="p">({</span><span class="n">distance</span><span class="p">[</span><span class="n">v</span><span class="p">],</span><span class="w"> </span><span class="n">v</span><span class="p">});</span>
<span class="linenos"> 74</span><span class="w">      </span><span class="p">}</span>
<span class="linenos"> 75</span><span class="w">    </span><span class="p">}</span>
<span class="linenos"> 76</span><span class="w">  </span><span class="p">}</span>
<span class="linenos"> 77</span>
<span class="linenos"> 78</span><span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">make_pair</span><span class="p">(</span><span class="n">predecessor</span><span class="p">,</span><span class="w"> </span><span class="n">distance</span><span class="p">);</span>
<span class="linenos"> 79</span><span class="p">}</span>
<span class="linenos"> 80</span>
<span class="linenos"> 81</span><span class="kt">int</span><span class="w"> </span><span class="n">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="linenos"> 82</span><span class="w">  </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;=== Prim&#39;s Minimum Spanning Tree ===&quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="linenos"> 83</span><span class="w">  </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Based on BGL Book Chapter 6&quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="linenos"> 84</span>
<span class="linenos"> 85</span><span class="w">  </span><span class="c1">// Create the same graph as in ch6_kruskal.cpp for comparison</span>
<span class="linenos"> 86</span><span class="w">  </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Graph: 7 vertices representing cities&quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="linenos"> 87</span><span class="w">  </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Same graph as Kruskal example for comparison&quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="linenos"> 88</span><span class="w">  </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="linenos"> 89</span>
<span class="linenos"> 90</span><span class="w">  </span><span class="c1">// For Prim&#39;s algorithm, we need an adjacency list (for efficient neighbor access)</span>
<span class="linenos"> 91</span><span class="w">  </span><span class="c1">// Using undirected graph, so we add edges in both directions</span>
<span class="linenos"> 92</span><span class="w">  </span><span class="n">edge_list</span><span class="o">&lt;</span><span class="n">directedness</span><span class="o">::</span><span class="n">undirected</span><span class="p">,</span><span class="w"> </span><span class="kt">double</span><span class="o">&gt;</span><span class="w"> </span><span class="n">edges</span><span class="p">(</span><span class="mi">7</span><span class="p">);</span>
<span class="linenos"> 93</span><span class="w">  </span><span class="n">edges</span><span class="p">.</span><span class="n">open_for_push_back</span><span class="p">();</span>
<span class="linenos"> 94</span><span class="w">  </span><span class="n">edges</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mf">7.0</span><span class="p">);</span><span class="w">   </span><span class="c1">// A-B</span>
<span class="linenos"> 95</span><span class="w">  </span><span class="n">edges</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="mf">5.0</span><span class="p">);</span><span class="w">   </span><span class="c1">// A-D</span>
<span class="linenos"> 96</span><span class="w">  </span><span class="n">edges</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mf">8.0</span><span class="p">);</span><span class="w">   </span><span class="c1">// B-C</span>
<span class="linenos"> 97</span><span class="w">  </span><span class="n">edges</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="mf">9.0</span><span class="p">);</span><span class="w">   </span><span class="c1">// B-D</span>
<span class="linenos"> 98</span><span class="w">  </span><span class="n">edges</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="mf">7.0</span><span class="p">);</span><span class="w">   </span><span class="c1">// B-E</span>
<span class="linenos"> 99</span><span class="w">  </span><span class="n">edges</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="mf">5.0</span><span class="p">);</span><span class="w">   </span><span class="c1">// C-E</span>
<span class="linenos">100</span><span class="w">  </span><span class="n">edges</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="mf">15.0</span><span class="p">);</span><span class="w">  </span><span class="c1">// D-E</span>
<span class="linenos">101</span><span class="w">  </span><span class="n">edges</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="mi">5</span><span class="p">,</span><span class="w"> </span><span class="mf">6.0</span><span class="p">);</span><span class="w">   </span><span class="c1">// D-F</span>
<span class="linenos">102</span><span class="w">  </span><span class="n">edges</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="mi">5</span><span class="p">,</span><span class="w"> </span><span class="mf">8.0</span><span class="p">);</span><span class="w">   </span><span class="c1">// E-F</span>
<span class="linenos">103</span><span class="w">  </span><span class="n">edges</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="mi">6</span><span class="p">,</span><span class="w"> </span><span class="mf">9.0</span><span class="p">);</span><span class="w">   </span><span class="c1">// E-G</span>
<span class="linenos">104</span><span class="w">  </span><span class="n">edges</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span><span class="w"> </span><span class="mi">6</span><span class="p">,</span><span class="w"> </span><span class="mf">11.0</span><span class="p">);</span><span class="w">  </span><span class="c1">// F-G</span>
<span class="linenos">105</span><span class="w">  </span><span class="n">edges</span><span class="p">.</span><span class="n">close_for_push_back</span><span class="p">();</span>
<span class="linenos">106</span>
<span class="linenos">107</span><span class="w">  </span><span class="c1">// Build symmetric adjacency list</span>
<span class="linenos">108</span><span class="w">  </span><span class="n">adjacency</span><span class="o">&lt;</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="kt">double</span><span class="o">&gt;</span><span class="w"> </span><span class="n">G</span><span class="p">(</span><span class="n">edges</span><span class="p">);</span>
<span class="linenos">109</span>
<span class="linenos">110</span><span class="w">  </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Running Prim&#39;s algorithm from vertex 0...&quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="linenos">111</span><span class="w">  </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="linenos">112</span>
<span class="linenos">113</span><span class="w">  </span><span class="k">auto</span><span class="w"> </span><span class="n">weight_fn</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[](</span><span class="k">auto</span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">edge</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">get</span><span class="o">&lt;</span><span class="mi">1</span><span class="o">&gt;</span><span class="p">(</span><span class="n">edge</span><span class="p">);</span><span class="w"> </span><span class="p">};</span>
<span class="linenos">114</span><span class="w">  </span><span class="k">auto</span><span class="w"> </span><span class="p">[</span><span class="n">predecessor</span><span class="p">,</span><span class="w"> </span><span class="n">key</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">prim_mst</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">weight_fn</span><span class="p">);</span>
<span class="linenos">115</span>
<span class="linenos">116</span><span class="w">  </span><span class="c1">// Display MST as predecessor tree</span>
<span class="linenos">117</span><span class="w">  </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;MST as predecessor array:&quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="linenos">118</span><span class="w">  </span><span class="kt">double</span><span class="w"> </span><span class="n">total_weight</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">0.0</span><span class="p">;</span>
<span class="linenos">119</span><span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">size_t</span><span class="w"> </span><span class="n">v</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">v</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">G</span><span class="p">.</span><span class="n">size</span><span class="p">();</span><span class="w"> </span><span class="o">++</span><span class="n">v</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="linenos">120</span><span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">predecessor</span><span class="p">[</span><span class="n">v</span><span class="p">]</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">numeric_limits</span><span class="o">&lt;</span><span class="kt">size_t</span><span class="o">&gt;::</span><span class="n">max</span><span class="p">())</span><span class="w"> </span><span class="p">{</span>
<span class="linenos">121</span><span class="w">      </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;  &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">predecessor</span><span class="p">[</span><span class="n">v</span><span class="p">]</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot; -&gt; &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">v</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot; : &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">key</span><span class="p">[</span><span class="n">v</span><span class="p">]</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="linenos">122</span><span class="w">      </span><span class="n">total_weight</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">key</span><span class="p">[</span><span class="n">v</span><span class="p">];</span>
<span class="linenos">123</span><span class="w">    </span><span class="p">}</span>
<span class="linenos">124</span><span class="w">  </span><span class="p">}</span>
<span class="linenos">125</span>
<span class="linenos">126</span><span class="w">  </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="linenos">127</span><span class="w">  </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Total MST weight: &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">total_weight</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="linenos">128</span><span class="w">  </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="linenos">129</span>
<span class="linenos">130</span><span class="w">  </span><span class="c1">// Show the key (distance) for each vertex</span>
<span class="linenos">131</span><span class="w">  </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Final key values (edge weight to MST):&quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="linenos">132</span><span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">size_t</span><span class="w"> </span><span class="n">v</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">v</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">G</span><span class="p">.</span><span class="n">size</span><span class="p">();</span><span class="w"> </span><span class="o">++</span><span class="n">v</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="linenos">133</span><span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;  Vertex &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">v</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;: &quot;</span><span class="p">;</span>
<span class="linenos">134</span><span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">key</span><span class="p">[</span><span class="n">v</span><span class="p">]</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">numeric_limits</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;::</span><span class="n">max</span><span class="p">())</span><span class="w"> </span><span class="p">{</span>
<span class="linenos">135</span><span class="w">      </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;inf (unreachable)&quot;</span><span class="p">;</span>
<span class="linenos">136</span><span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span>
<span class="linenos">137</span><span class="w">      </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">key</span><span class="p">[</span><span class="n">v</span><span class="p">];</span>
<span class="linenos">138</span><span class="w">    </span><span class="p">}</span>
<span class="linenos">139</span><span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="linenos">140</span><span class="w">  </span><span class="p">}</span>
<span class="linenos">141</span>
<span class="linenos">142</span><span class="w">  </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="linenos">143</span><span class="w">  </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Note: Both Kruskal and Prim produce the same MST weight (39.0)&quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="linenos">144</span><span class="w">  </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Prim grows the tree from a single vertex, Kruskal merges forests.&quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="linenos">145</span>
<span class="linenos">146</span><span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="linenos">147</span><span class="p">}</span>
</pre></div>
</div>
</div>
</section>
<section id="building-and-running-the-example">
<h2>Building and Running the Example<a class="headerlink" href="#building-and-running-the-example" title="Link to this heading"></a></h2>
<p>First, configure and build the example:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span><span class="c1"># From the NWGraph root directory</span>
mkdir<span class="w"> </span>-p<span class="w"> </span>build<span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="nb">cd</span><span class="w"> </span>build
cmake<span class="w"> </span>..<span class="w"> </span>-DNWGRAPH_BUILD_EXAMPLES<span class="o">=</span>ON
make<span class="w"> </span>ch6_prim
</pre></div>
</div>
<p>Then run the example:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>./examples/bgl-book/ch6_prim
</pre></div>
</div>
<p>The program computes the MST starting from an arbitrary vertex and outputs the
predecessor map representing the tree.</p>
</section>
<section id="sample-output">
<h2>Sample Output<a class="headerlink" href="#sample-output" title="Link to this heading"></a></h2>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>Telephone Network MST (Prim&#39;s Algorithm)

Starting vertex: Nobel

MST edges (via predecessor map):
Parry Sound&#39;s parent: Nobel (3 miles)
McKellar&#39;s parent: Parry Sound (9 miles)
...

Total wire required: 145 miles
</pre></div>
</div>
</section>
<section id="key-nwgraph-features-demonstrated">
<h2>Key NWGraph Features Demonstrated<a class="headerlink" href="#key-nwgraph-features-demonstrated" title="Link to this heading"></a></h2>
<ul class="simple">
<li><p><strong>Priority queue traversal</strong>: Similar to Dijkstra’s algorithm</p></li>
<li><p><strong>Predecessor maps</strong>: Recording the MST structure</p></li>
<li><p><strong>Weighted undirected graphs</strong>: Road networks with distances</p></li>
<li><p><strong>Greedy algorithm</strong>: Always selecting the minimum weight edge</p></li>
</ul>
</section>
<section id="references">
<h2>References<a class="headerlink" href="#references" title="Link to this heading"></a></h2>
<ul class="simple">
<li><p>Cormen, Leiserson, Rivest, and Stein. <em>Introduction to Algorithms</em>, 4th Edition (2022),
<strong>Chapter 21.2: Kruskal’s and Prim’s Algorithms</strong></p></li>
<li><p>Siek, Lee, and Lumsdaine. <em>The Boost Graph Library</em> (2002), Chapter 6.4</p></li>
</ul>
</section>
<section id="see-also">
<h2>See Also<a class="headerlink" href="#see-also" title="Link to this heading"></a></h2>
<ul class="simple">
<li><p><a class="reference internal" href="ch6_kruskal.html"><span class="doc">Kruskal’s Minimum Spanning Tree Algorithm (BGL Book Chapter 6)</span></a> - Kruskal’s MST algorithm (edge-centric approach)</p></li>
<li><p><a class="reference internal" href="ch5_dijkstra.html"><span class="doc">Internet Routing with Dijkstra’s Algorithm (BGL Book Chapter 5.4)</span></a> - Dijkstra’s shortest paths (similar algorithm structure)</p></li>
<li><p><a class="reference internal" href="index.html"><span class="doc">Boost Graph Library Examples (Rewritten for NW Graph)</span></a> - BGL Book examples overview</p></li>
</ul>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="ch6_kruskal.html" class="btn btn-neutral float-left" title="Kruskal’s Minimum Spanning Tree Algorithm (BGL Book Chapter 6)" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="ch7_connected.html" class="btn btn-neutral float-right" title="Connected Components (BGL Book Chapter 7)" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2020-2022, PNNL, UW.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>