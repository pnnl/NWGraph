

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../../">
<head>
  <meta charset="utf-8" /><meta name="viewport" content="width=device-width, initial-scale=1" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Bellman-Ford Algorithm and Distance Vector Routing (BGL Book Chapter 5.3) &mdash; NW Graph 0.10.15 documentation</title>
      <link rel="stylesheet" type="text/css" href="../../_static/pygments.css?v=649a27d8" />
      <link rel="stylesheet" type="text/css" href="../../_static/css/theme.css?v=9edc463e" />
      <link rel="stylesheet" type="text/css" href="../../_static/graphviz.css?v=4ae1632d" />
      <link rel="stylesheet" type="text/css" href="../../_static/collapsible-lists/css/tree_view.css?v=a885cde7" />
      <link rel="stylesheet" type="text/css" href="../../_static/css/custom.css?v=afbbf639" />

  
      <script src="../../_static/jquery.js?v=5d32c60e"></script>
      <script src="../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="../../_static/documentation_options.js?v=a8af70a8"></script>
      <script src="../../_static/doctools.js?v=fd6eb6e6"></script>
      <script src="../../_static/sphinx_highlight.js?v=6ffebe34"></script>
      <script src="../../_static/collapsible-lists/js/CollapsibleLists.compressed.js?v=73120307"></script>
      <script src="../../_static/collapsible-lists/js/apply-collapsible-lists.js?v=660e4f45"></script>
    <script src="../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <link rel="next" title="Kruskal’s Minimum Spanning Tree Algorithm (BGL Book Chapter 6)" href="ch6_kruskal.html" />
    <link rel="prev" title="Internet Routing with Dijkstra’s Algorithm (BGL Book Chapter 5.4)" href="ch5_dijkstra.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../index.html" class="icon icon-home">
            NW Graph
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../userguide/getting_started.html">Quickstart</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../userguide/benchmarking.html">Benchmarking with NWGraph</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../userguide/introduction.html">NWGraph: The Northwest Graph Library</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../userguide/graph-background-ii.html">Graph Background</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../userguide/generic-programming.html">Generic Programming in C++20</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../userguide/graph-concepts.html">Generic Graph Algorithms</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../userguide/algorithms.html">NWGraph Algorithms</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../userguide/adaptors.html">Graph Range Adaptors</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../userguide/data-structures.html">Model Data Structures</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../userguide/performance.html">Performance Evaluation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../userguide/related.html">Related Libraries and Toolkits</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../userguide/references.html">References Cited</a></li>
</ul>
<ul class="current">
<li class="toctree-l1 current"><a class="reference internal" href="../index.html">Examples</a><ul class="current">
<li class="toctree-l2 current"><a class="reference internal" href="index.html">Boost Graph Library Examples (Rewritten for NW Graph)</a><ul class="current">
<li class="toctree-l3"><a class="reference internal" href="ch3_toposort.html">File Dependencies - Topological Sort (BGL Book Chapter 3)</a></li>
<li class="toctree-l3"><a class="reference internal" href="ch4_kevin_bacon.html">Six Degrees of Kevin Bacon (BGL Book Chapter 4.1)</a></li>
<li class="toctree-l3"><a class="reference internal" href="ch4_loop_detection.html">Finding Loops in Program Control-Flow Graphs (BGL Book Chapter 4.2)</a></li>
<li class="toctree-l3"><a class="reference internal" href="ch5_dijkstra.html">Internet Routing with Dijkstra’s Algorithm (BGL Book Chapter 5.4)</a></li>
<li class="toctree-l3 current"><a class="current reference internal" href="#">Bellman-Ford Algorithm and Distance Vector Routing (BGL Book Chapter 5.3)</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#overview">Overview</a></li>
<li class="toctree-l4"><a class="reference internal" href="#distance-vector-routing">Distance Vector Routing</a></li>
<li class="toctree-l4"><a class="reference internal" href="#the-bellman-ford-algorithm">The Bellman-Ford Algorithm</a></li>
<li class="toctree-l4"><a class="reference internal" href="#nwgraph-implementation">NWGraph Implementation</a></li>
<li class="toctree-l4"><a class="reference internal" href="#building-and-running-the-example">Building and Running the Example</a></li>
<li class="toctree-l4"><a class="reference internal" href="#sample-output">Sample Output</a></li>
<li class="toctree-l4"><a class="reference internal" href="#key-nwgraph-features-demonstrated">Key NWGraph Features Demonstrated</a></li>
<li class="toctree-l4"><a class="reference internal" href="#references">References</a></li>
<li class="toctree-l4"><a class="reference internal" href="#see-also">See Also</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="ch6_kruskal.html">Kruskal’s Minimum Spanning Tree Algorithm (BGL Book Chapter 6)</a></li>
<li class="toctree-l3"><a class="reference internal" href="ch6_prim.html">Prim’s Minimum Spanning Tree Algorithm (BGL Book Chapter 6)</a></li>
<li class="toctree-l3"><a class="reference internal" href="ch7_connected.html">Connected Components (BGL Book Chapter 7)</a></li>
<li class="toctree-l3"><a class="reference internal" href="ch7_strongly_connected.html">Strongly Connected Components and Web Page Links (BGL Book Chapter 7.3)</a></li>
<li class="toctree-l3"><a class="reference internal" href="ch8_maxflow.html">Maximum Flow (BGL Book Chapter 8)</a></li>
<li class="toctree-l3"><a class="reference internal" href="ch9_knights_tour.html">Implicit Graphs: A Knight’s Tour (BGL Book Chapter 9)</a></li>
<li class="toctree-l3"><a class="reference internal" href="index.html#overview">Overview</a></li>
<li class="toctree-l3"><a class="reference internal" href="index.html#building-the-examples">Building the Examples</a></li>
<li class="toctree-l3"><a class="reference internal" href="index.html#running-the-examples">Running the Examples</a></li>
<li class="toctree-l3"><a class="reference internal" href="index.html#reference">Reference</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../degrees/index.html">Six Degrees of Separation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../imdb/index.html">IMDB Network Analysis Examples</a></li>
<li class="toctree-l2"><a class="reference internal" href="../index.html#bgl-book-examples">BGL Book Examples</a></li>
<li class="toctree-l2"><a class="reference internal" href="../index.html#six-degrees-of-separation">Six Degrees of Separation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../index.html#imdb-examples">IMDB Examples</a></li>
</ul>
</li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../nwgraph_api.html">NWGraph API Reference</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">NW Graph</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../index.html">Examples</a></li>
          <li class="breadcrumb-item"><a href="index.html">Boost Graph Library Examples (Rewritten for NW Graph)</a></li>
      <li class="breadcrumb-item active">Bellman-Ford Algorithm and Distance Vector Routing (BGL Book Chapter 5.3)</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../../_sources/examples/bglbook/ch5_bellman_ford.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="bellman-ford-algorithm-and-distance-vector-routing-bgl-book-chapter-5-3">
<h1>Bellman-Ford Algorithm and Distance Vector Routing (BGL Book Chapter 5.3)<a class="headerlink" href="#bellman-ford-algorithm-and-distance-vector-routing-bgl-book-chapter-5-3" title="Link to this heading"></a></h1>
<p><em>Based on “The Boost Graph Library” by Jeremy Siek, Lie-Quan Lee, and Andrew Lumsdaine</em></p>
<section id="overview">
<h2>Overview<a class="headerlink" href="#overview" title="Link to this heading"></a></h2>
<p>The routing problem can be modeled as a graph by associating a vertex with each router
and an edge for each direct connection between two routers. Information such as delay
and bandwidth are attached to each edge. The routing problem is now transformed into
a shortest-paths graph problem.</p>
<p>The ultimate goal of a routing process is to deliver packets to their destinations as
quickly as possible. There are a number of factors that determine how long a packet
takes to arrive (e.g., the number of hops along the path, transmission delay within
a router, transmission delay between routers, network bandwidth). The routing protocol
must choose the best paths between routers; this information is stored in a routing table.</p>
</section>
<section id="distance-vector-routing">
<h2>Distance Vector Routing<a class="headerlink" href="#distance-vector-routing" title="Link to this heading"></a></h2>
<p>Some of the first Internet routing protocols, such as the <strong>Routing Information Protocol
(RIP)</strong>, used a distance-vector protocol. The basic idea behind RIP is for each router
to maintain an estimate of distance to all other routers and to periodically compare
notes with its neighbors.</p>
<p>If a router learns of a shorter path to some destination from one of its neighbors, it
will update its distance record to that destination and change its routing table to send
packets to that destination via that neighbor. After enough time, the estimated distances
maintained in this distributed fashion by multiple routers are guaranteed to converge to
the true distance.</p>
</section>
<section id="the-bellman-ford-algorithm">
<h2>The Bellman-Ford Algorithm<a class="headerlink" href="#the-bellman-ford-algorithm" title="Link to this heading"></a></h2>
<p>RIP is a distributed form of the <strong>Bellman-Ford shortest paths algorithm</strong>. The principle
step in the Bellman-Ford algorithm, called <strong>edge relaxation</strong>, corresponds to the notion
of “comparing notes with your neighbor.”</p>
<p>The relaxation operation applied to edge (u, v) performs the following update:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>d[v] = min(w(u, v) + d[u], d[v])
</pre></div>
</div>
<p>The Bellman-Ford algorithm loops through all of the edges in a graph, applying the
relaxation operation to each. The algorithm repeats this loop <a href="#id2"><span class="problematic" id="id3">|V|</span></a> times, after which
it is guaranteed that the distances to each vertex have been reduced to the minimum
possible (unless there is a negative cycle in the graph).</p>
<section id="negative-cycle-detection">
<h3>Negative Cycle Detection<a class="headerlink" href="#negative-cycle-detection" title="Link to this heading"></a></h3>
<p>If there is a negative cycle, then there will be edges in the graph that were not
properly minimized. To verify that all edges are minimized, the algorithm loops over
all of the edges in the graph a final time, returning <code class="docutils literal notranslate"><span class="pre">true</span></code> if they are minimized,
and returning <code class="docutils literal notranslate"><span class="pre">false</span></code> otherwise.</p>
</section>
<section id="comparison-with-dijkstra">
<h3>Comparison with Dijkstra<a class="headerlink" href="#comparison-with-dijkstra" title="Link to this heading"></a></h3>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>Feature</p></th>
<th class="head"><p>Bellman-Ford</p></th>
<th class="head"><p>Dijkstra</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>Time complexity</p></td>
<td><p>O(V * E)</p></td>
<td><p>O((V+E) log V)</p></td>
</tr>
<tr class="row-odd"><td><p>Negative weights</p></td>
<td><p>Yes</p></td>
<td><p>No</p></td>
</tr>
<tr class="row-even"><td><p>Negative cycle detect</p></td>
<td><p>Yes</p></td>
<td><p>No</p></td>
</tr>
<tr class="row-odd"><td><p>Distributed version</p></td>
<td><p>Yes (RIP)</p></td>
<td><p>No</p></td>
</tr>
</tbody>
</table>
</section>
</section>
<section id="nwgraph-implementation">
<h2>NWGraph Implementation<a class="headerlink" href="#nwgraph-implementation" title="Link to this heading"></a></h2>
<p>NWGraph provides a <code class="docutils literal notranslate"><span class="pre">bellman_ford</span></code> function that implements the Bellman-Ford algorithm.</p>
<div class="literal-block-wrapper docutils container" id="id1">
<div class="code-block-caption"><span class="caption-number">Listing 5 </span><span class="caption-text">Complete source code</span><a class="headerlink" href="#id1" title="Link to this code"></a></div>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="linenos">  1</span><span class="cm">/**</span>
<span class="linenos">  2</span><span class="cm"> * @file ch5_bellman_ford.cpp</span>
<span class="linenos">  3</span><span class="cm"> *</span>
<span class="linenos">  4</span><span class="cm"> * @brief Bellman-Ford Algorithm and Distance Vector Routing (BGL Book Chapter 5.3)</span>
<span class="linenos">  5</span><span class="cm"> *</span>
<span class="linenos">  6</span><span class="cm"> * This example demonstrates the Bellman-Ford single-source shortest-paths algorithm</span>
<span class="linenos">  7</span><span class="cm"> * applied to a router network. The Bellman-Ford algorithm can handle graphs with</span>
<span class="linenos">  8</span><span class="cm"> * negative edge weights (unlike Dijkstra) and can detect negative cycles.</span>
<span class="linenos">  9</span><span class="cm"> *</span>
<span class="linenos"> 10</span><span class="cm"> * The algorithm is the basis for distance-vector routing protocols like RIP</span>
<span class="linenos"> 11</span><span class="cm"> * (Routing Information Protocol), where routers periodically exchange distance</span>
<span class="linenos"> 12</span><span class="cm"> * estimates with neighbors.</span>
<span class="linenos"> 13</span><span class="cm"> *</span>
<span class="linenos"> 14</span><span class="cm"> * Key differences from Dijkstra:</span>
<span class="linenos"> 15</span><span class="cm"> * - Can handle negative edge weights</span>
<span class="linenos"> 16</span><span class="cm"> * - Slower: O(V*E) vs O((V+E)log V)</span>
<span class="linenos"> 17</span><span class="cm"> * - Can detect negative cycles</span>
<span class="linenos"> 18</span><span class="cm"> *</span>
<span class="linenos"> 19</span><span class="cm"> * @copyright SPDX-FileCopyrightText: 2022 Battelle Memorial Institute</span>
<span class="linenos"> 20</span><span class="cm"> * @copyright SPDX-FileCopyrightText: 2022 University of Washington</span>
<span class="linenos"> 21</span><span class="cm"> *</span>
<span class="linenos"> 22</span><span class="cm"> * SPDX-License-Identifier: BSD-3-Clause</span>
<span class="linenos"> 23</span><span class="cm"> *</span>
<span class="linenos"> 24</span><span class="cm"> * @authors</span>
<span class="linenos"> 25</span><span class="cm"> *   Andrew Lumsdaine</span>
<span class="linenos"> 26</span><span class="cm"> *</span>
<span class="linenos"> 27</span><span class="cm"> */</span>
<span class="linenos"> 28</span>
<span class="linenos"> 29</span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;iostream&gt;</span>
<span class="linenos"> 30</span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;limits&gt;</span>
<span class="linenos"> 31</span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;vector&gt;</span>
<span class="linenos"> 32</span>
<span class="linenos"> 33</span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;nwgraph/adjacency.hpp&quot;</span>
<span class="linenos"> 34</span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;nwgraph/edge_list.hpp&quot;</span>
<span class="linenos"> 35</span>
<span class="linenos"> 36</span><span class="k">using</span><span class="w"> </span><span class="k">namespace</span><span class="w"> </span><span class="nn">nw</span><span class="o">::</span><span class="nn">graph</span><span class="p">;</span>
<span class="linenos"> 37</span>
<span class="linenos"> 38</span><span class="cm">/**</span>
<span class="linenos"> 39</span><span class="cm"> * @brief Bellman-Ford shortest paths algorithm</span>
<span class="linenos"> 40</span><span class="cm"> *</span>
<span class="linenos"> 41</span><span class="cm"> * Computes shortest paths from a source vertex to all other vertices.</span>
<span class="linenos"> 42</span><span class="cm"> * Returns false if a negative cycle is detected, true otherwise.</span>
<span class="linenos"> 43</span><span class="cm"> *</span>
<span class="linenos"> 44</span><span class="cm"> * The algorithm works by repeatedly relaxing all edges |V|-1 times.</span>
<span class="linenos"> 45</span><span class="cm"> * After this, all shortest paths are found (if no negative cycles exist).</span>
<span class="linenos"> 46</span><span class="cm"> * A final pass checks for negative cycles.</span>
<span class="linenos"> 47</span><span class="cm"> */</span>
<span class="linenos"> 48</span><span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">EdgeList</span><span class="p">,</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">Weight</span><span class="o">&gt;</span>
<span class="linenos"> 49</span><span class="k">auto</span><span class="w"> </span><span class="n">bellman_ford</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">EdgeList</span><span class="o">&amp;</span><span class="w"> </span><span class="n">edges</span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">num_vertices</span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">source</span><span class="p">,</span><span class="w"> </span><span class="n">Weight</span><span class="w"> </span><span class="n">weight_fn</span><span class="p">)</span>
<span class="linenos"> 50</span><span class="w">    </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="kt">bool</span><span class="p">,</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="p">,</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">size_t</span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="linenos"> 51</span>
<span class="linenos"> 52</span><span class="w">  </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="w"> </span><span class="n">distance</span><span class="p">(</span><span class="n">num_vertices</span><span class="p">,</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">numeric_limits</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;::</span><span class="n">max</span><span class="p">());</span>
<span class="linenos"> 53</span><span class="w">  </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">size_t</span><span class="o">&gt;</span><span class="w"> </span><span class="n">predecessor</span><span class="p">(</span><span class="n">num_vertices</span><span class="p">);</span>
<span class="linenos"> 54</span>
<span class="linenos"> 55</span><span class="w">  </span><span class="c1">// Initialize predecessor to self (no predecessor)</span>
<span class="linenos"> 56</span><span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">size_t</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">num_vertices</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="linenos"> 57</span><span class="w">    </span><span class="n">predecessor</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">i</span><span class="p">;</span>
<span class="linenos"> 58</span><span class="w">  </span><span class="p">}</span>
<span class="linenos"> 59</span>
<span class="linenos"> 60</span><span class="w">  </span><span class="n">distance</span><span class="p">[</span><span class="n">source</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="linenos"> 61</span>
<span class="linenos"> 62</span><span class="w">  </span><span class="c1">// Relax all edges |V|-1 times</span>
<span class="linenos"> 63</span><span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">size_t</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">num_vertices</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="linenos"> 64</span><span class="w">    </span><span class="kt">bool</span><span class="w"> </span><span class="n">changed</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span>
<span class="linenos"> 65</span><span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="k">auto</span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">edge</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">edges</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="linenos"> 66</span><span class="w">      </span><span class="k">auto</span><span class="w"> </span><span class="n">u</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">get</span><span class="o">&lt;</span><span class="mi">0</span><span class="o">&gt;</span><span class="p">(</span><span class="n">edge</span><span class="p">);</span>
<span class="linenos"> 67</span><span class="w">      </span><span class="k">auto</span><span class="w"> </span><span class="n">v</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">get</span><span class="o">&lt;</span><span class="mi">1</span><span class="o">&gt;</span><span class="p">(</span><span class="n">edge</span><span class="p">);</span>
<span class="linenos"> 68</span><span class="w">      </span><span class="k">auto</span><span class="w"> </span><span class="n">w</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">weight_fn</span><span class="p">(</span><span class="n">edge</span><span class="p">);</span>
<span class="linenos"> 69</span>
<span class="linenos"> 70</span><span class="w">      </span><span class="c1">// Relaxation step</span>
<span class="linenos"> 71</span><span class="w">      </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">distance</span><span class="p">[</span><span class="n">u</span><span class="p">]</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">numeric_limits</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;::</span><span class="n">max</span><span class="p">()</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">distance</span><span class="p">[</span><span class="n">u</span><span class="p">]</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">w</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">distance</span><span class="p">[</span><span class="n">v</span><span class="p">])</span><span class="w"> </span><span class="p">{</span>
<span class="linenos"> 72</span><span class="w">        </span><span class="n">distance</span><span class="p">[</span><span class="n">v</span><span class="p">]</span><span class="w">    </span><span class="o">=</span><span class="w"> </span><span class="n">distance</span><span class="p">[</span><span class="n">u</span><span class="p">]</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">w</span><span class="p">;</span>
<span class="linenos"> 73</span><span class="w">        </span><span class="n">predecessor</span><span class="p">[</span><span class="n">v</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">u</span><span class="p">;</span>
<span class="linenos"> 74</span><span class="w">        </span><span class="n">changed</span><span class="w">        </span><span class="o">=</span><span class="w"> </span><span class="nb">true</span><span class="p">;</span>
<span class="linenos"> 75</span><span class="w">      </span><span class="p">}</span>
<span class="linenos"> 76</span><span class="w">    </span><span class="p">}</span>
<span class="linenos"> 77</span><span class="w">    </span><span class="c1">// Early termination if no changes</span>
<span class="linenos"> 78</span><span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">changed</span><span class="p">)</span><span class="w"> </span><span class="k">break</span><span class="p">;</span>
<span class="linenos"> 79</span><span class="w">  </span><span class="p">}</span>
<span class="linenos"> 80</span>
<span class="linenos"> 81</span><span class="w">  </span><span class="c1">// Check for negative cycles</span>
<span class="linenos"> 82</span><span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="k">auto</span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">edge</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">edges</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="linenos"> 83</span><span class="w">    </span><span class="k">auto</span><span class="w"> </span><span class="n">u</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">get</span><span class="o">&lt;</span><span class="mi">0</span><span class="o">&gt;</span><span class="p">(</span><span class="n">edge</span><span class="p">);</span>
<span class="linenos"> 84</span><span class="w">    </span><span class="k">auto</span><span class="w"> </span><span class="n">v</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">get</span><span class="o">&lt;</span><span class="mi">1</span><span class="o">&gt;</span><span class="p">(</span><span class="n">edge</span><span class="p">);</span>
<span class="linenos"> 85</span><span class="w">    </span><span class="k">auto</span><span class="w"> </span><span class="n">w</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">weight_fn</span><span class="p">(</span><span class="n">edge</span><span class="p">);</span>
<span class="linenos"> 86</span>
<span class="linenos"> 87</span><span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">distance</span><span class="p">[</span><span class="n">u</span><span class="p">]</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">numeric_limits</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;::</span><span class="n">max</span><span class="p">()</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">distance</span><span class="p">[</span><span class="n">u</span><span class="p">]</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">w</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">distance</span><span class="p">[</span><span class="n">v</span><span class="p">])</span><span class="w"> </span><span class="p">{</span>
<span class="linenos"> 88</span><span class="w">      </span><span class="c1">// Negative cycle detected</span>
<span class="linenos"> 89</span><span class="w">      </span><span class="k">return</span><span class="w"> </span><span class="p">{</span><span class="nb">false</span><span class="p">,</span><span class="w"> </span><span class="n">distance</span><span class="p">,</span><span class="w"> </span><span class="n">predecessor</span><span class="p">};</span>
<span class="linenos"> 90</span><span class="w">    </span><span class="p">}</span>
<span class="linenos"> 91</span><span class="w">  </span><span class="p">}</span>
<span class="linenos"> 92</span>
<span class="linenos"> 93</span><span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="p">{</span><span class="nb">true</span><span class="p">,</span><span class="w"> </span><span class="n">distance</span><span class="p">,</span><span class="w"> </span><span class="n">predecessor</span><span class="p">};</span>
<span class="linenos"> 94</span><span class="p">}</span>
<span class="linenos"> 95</span>
<span class="linenos"> 96</span><span class="kt">int</span><span class="w"> </span><span class="n">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="linenos"> 97</span><span class="w">  </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;=== Bellman-Ford Algorithm and Distance Vector Routing ===&quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="linenos"> 98</span><span class="w">  </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Based on BGL Book Chapter 5.3&quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="linenos"> 99</span>
<span class="linenos">100</span><span class="w">  </span><span class="c1">// Router network from the BGL book example</span>
<span class="linenos">101</span><span class="w">  </span><span class="c1">// Vertices represent routers: A=0, B=1, C=2, D=3, E=4, F=5, G=6, H=7</span>
<span class="linenos">102</span><span class="w">  </span><span class="c1">// Edge weights represent transmission delays</span>
<span class="linenos">103</span><span class="w">  </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="n">router_names</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;ABCDEFGH&quot;</span><span class="p">;</span>
<span class="linenos">104</span><span class="w">  </span><span class="k">const</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">num_routers</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">8</span><span class="p">;</span>
<span class="linenos">105</span>
<span class="linenos">106</span><span class="w">  </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Router network with transmission delays:&quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="linenos">107</span><span class="w">  </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;  A connects to B (5.0) and C (1.0)&quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="linenos">108</span><span class="w">  </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;  B connects to D (1.3) and E (3.0)&quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="linenos">109</span><span class="w">  </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;  C connects to E (10.0) and F (2.0)&quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="linenos">110</span><span class="w">  </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;  D connects to E (0.4) and H (6.3)&quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="linenos">111</span><span class="w">  </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;  E connects to H (1.3)&quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="linenos">112</span><span class="w">  </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;  F connects to G (1.2)&quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="linenos">113</span><span class="w">  </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;  G connects to H (0.5)&quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="linenos">114</span><span class="w">  </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="linenos">115</span>
<span class="linenos">116</span><span class="w">  </span><span class="c1">// Create edge list with transmission delays</span>
<span class="linenos">117</span><span class="w">  </span><span class="c1">// Using directed edges as in the BGL book example</span>
<span class="linenos">118</span><span class="w">  </span><span class="n">edge_list</span><span class="o">&lt;</span><span class="n">directedness</span><span class="o">::</span><span class="n">directed</span><span class="p">,</span><span class="w"> </span><span class="kt">double</span><span class="o">&gt;</span><span class="w"> </span><span class="n">edges</span><span class="p">(</span><span class="n">num_routers</span><span class="p">);</span>
<span class="linenos">119</span><span class="w">  </span><span class="n">edges</span><span class="p">.</span><span class="n">open_for_push_back</span><span class="p">();</span>
<span class="linenos">120</span>
<span class="linenos">121</span><span class="w">  </span><span class="c1">// Edges from the BGL book Figure 5.2</span>
<span class="linenos">122</span><span class="w">  </span><span class="n">edges</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mf">5.0</span><span class="p">);</span><span class="w">   </span><span class="c1">// A -&gt; B</span>
<span class="linenos">123</span><span class="w">  </span><span class="n">edges</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mf">1.0</span><span class="p">);</span><span class="w">   </span><span class="c1">// A -&gt; C</span>
<span class="linenos">124</span><span class="w">  </span><span class="n">edges</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="mf">1.3</span><span class="p">);</span><span class="w">   </span><span class="c1">// B -&gt; D</span>
<span class="linenos">125</span><span class="w">  </span><span class="n">edges</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="mf">3.0</span><span class="p">);</span><span class="w">   </span><span class="c1">// B -&gt; E</span>
<span class="linenos">126</span><span class="w">  </span><span class="n">edges</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="mf">10.0</span><span class="p">);</span><span class="w">  </span><span class="c1">// C -&gt; E</span>
<span class="linenos">127</span><span class="w">  </span><span class="n">edges</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">5</span><span class="p">,</span><span class="w"> </span><span class="mf">2.0</span><span class="p">);</span><span class="w">   </span><span class="c1">// C -&gt; F</span>
<span class="linenos">128</span><span class="w">  </span><span class="n">edges</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="mi">7</span><span class="p">,</span><span class="w"> </span><span class="mf">6.3</span><span class="p">);</span><span class="w">   </span><span class="c1">// D -&gt; H</span>
<span class="linenos">129</span><span class="w">  </span><span class="n">edges</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="mf">0.4</span><span class="p">);</span><span class="w">   </span><span class="c1">// D -&gt; E</span>
<span class="linenos">130</span><span class="w">  </span><span class="n">edges</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="mi">7</span><span class="p">,</span><span class="w"> </span><span class="mf">1.3</span><span class="p">);</span><span class="w">   </span><span class="c1">// E -&gt; H</span>
<span class="linenos">131</span><span class="w">  </span><span class="n">edges</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span><span class="w"> </span><span class="mi">6</span><span class="p">,</span><span class="w"> </span><span class="mf">1.2</span><span class="p">);</span><span class="w">   </span><span class="c1">// F -&gt; G</span>
<span class="linenos">132</span><span class="w">  </span><span class="n">edges</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="mi">6</span><span class="p">,</span><span class="w"> </span><span class="mi">7</span><span class="p">,</span><span class="w"> </span><span class="mf">0.5</span><span class="p">);</span><span class="w">   </span><span class="c1">// G -&gt; H</span>
<span class="linenos">133</span>
<span class="linenos">134</span><span class="w">  </span><span class="n">edges</span><span class="p">.</span><span class="n">close_for_push_back</span><span class="p">();</span>
<span class="linenos">135</span>
<span class="linenos">136</span><span class="w">  </span><span class="c1">// Run Bellman-Ford from router A (vertex 0)</span>
<span class="linenos">137</span><span class="w">  </span><span class="kt">size_t</span><span class="w"> </span><span class="n">source</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w">  </span><span class="c1">// Router A</span>
<span class="linenos">138</span><span class="w">  </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Computing shortest paths from router &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">router_names</span><span class="p">[</span><span class="n">source</span><span class="p">]</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;...&quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="linenos">139</span><span class="w">  </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="linenos">140</span>
<span class="linenos">141</span><span class="w">  </span><span class="k">auto</span><span class="w"> </span><span class="n">weight_fn</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[](</span><span class="k">auto</span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">edge</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">get</span><span class="o">&lt;</span><span class="mi">2</span><span class="o">&gt;</span><span class="p">(</span><span class="n">edge</span><span class="p">);</span><span class="w"> </span><span class="p">};</span>
<span class="linenos">142</span><span class="w">  </span><span class="k">auto</span><span class="w"> </span><span class="p">[</span><span class="n">success</span><span class="p">,</span><span class="w"> </span><span class="n">distance</span><span class="p">,</span><span class="w"> </span><span class="n">predecessor</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">bellman_ford</span><span class="p">(</span><span class="n">edges</span><span class="p">,</span><span class="w"> </span><span class="n">num_routers</span><span class="p">,</span><span class="w"> </span><span class="n">source</span><span class="p">,</span><span class="w"> </span><span class="n">weight_fn</span><span class="p">);</span>
<span class="linenos">143</span>
<span class="linenos">144</span><span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">success</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="linenos">145</span><span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Shortest path distances and predecessors:&quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="linenos">146</span><span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">(</span><span class="mi">40</span><span class="p">,</span><span class="w"> </span><span class="sc">&#39;-&#39;</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="linenos">147</span>
<span class="linenos">148</span><span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">size_t</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">num_routers</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="linenos">149</span><span class="w">      </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;  &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">router_names</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;: &quot;</span><span class="p">;</span>
<span class="linenos">150</span><span class="w">      </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">distance</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">numeric_limits</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;::</span><span class="n">max</span><span class="p">())</span><span class="w"> </span><span class="p">{</span>
<span class="linenos">151</span><span class="w">        </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;unreachable&quot;</span><span class="p">;</span>
<span class="linenos">152</span><span class="w">      </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span>
<span class="linenos">153</span><span class="w">        </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">distance</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;  (via &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">router_names</span><span class="p">[</span><span class="n">predecessor</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;)&quot;</span><span class="p">;</span>
<span class="linenos">154</span><span class="w">      </span><span class="p">}</span>
<span class="linenos">155</span><span class="w">      </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="linenos">156</span><span class="w">    </span><span class="p">}</span>
<span class="linenos">157</span>
<span class="linenos">158</span><span class="w">    </span><span class="c1">// Trace path to H</span>
<span class="linenos">159</span><span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="linenos">160</span><span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Shortest path from A to H:&quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="linenos">161</span><span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;  &quot;</span><span class="p">;</span>
<span class="linenos">162</span>
<span class="linenos">163</span><span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">size_t</span><span class="o">&gt;</span><span class="w"> </span><span class="n">path</span><span class="p">;</span>
<span class="linenos">164</span><span class="w">    </span><span class="kt">size_t</span><span class="w"> </span><span class="n">current</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">7</span><span class="p">;</span><span class="w">  </span><span class="c1">// H</span>
<span class="linenos">165</span><span class="w">    </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="n">current</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">source</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="linenos">166</span><span class="w">      </span><span class="n">path</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">current</span><span class="p">);</span>
<span class="linenos">167</span><span class="w">      </span><span class="n">current</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">predecessor</span><span class="p">[</span><span class="n">current</span><span class="p">];</span>
<span class="linenos">168</span><span class="w">    </span><span class="p">}</span>
<span class="linenos">169</span><span class="w">    </span><span class="n">path</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">source</span><span class="p">);</span>
<span class="linenos">170</span>
<span class="linenos">171</span><span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="k">auto</span><span class="w"> </span><span class="n">it</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">path</span><span class="p">.</span><span class="n">rbegin</span><span class="p">();</span><span class="w"> </span><span class="n">it</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">path</span><span class="p">.</span><span class="n">rend</span><span class="p">();</span><span class="w"> </span><span class="o">++</span><span class="n">it</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="linenos">172</span><span class="w">      </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">router_names</span><span class="p">[</span><span class="o">*</span><span class="n">it</span><span class="p">];</span>
<span class="linenos">173</span><span class="w">      </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">it</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">path</span><span class="p">.</span><span class="n">rend</span><span class="p">())</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot; -&gt; &quot;</span><span class="p">;</span>
<span class="linenos">174</span><span class="w">    </span><span class="p">}</span>
<span class="linenos">175</span><span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="linenos">176</span><span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;  Total delay: &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">distance</span><span class="p">[</span><span class="mi">7</span><span class="p">]</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="linenos">177</span>
<span class="linenos">178</span><span class="w">  </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span>
<span class="linenos">179</span><span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Negative cycle detected in the network!&quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="linenos">180</span><span class="w">  </span><span class="p">}</span>
<span class="linenos">181</span>
<span class="linenos">182</span><span class="w">  </span><span class="c1">// Example with a negative cycle</span>
<span class="linenos">183</span><span class="w">  </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="linenos">184</span><span class="w">  </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;=== Example with Negative Cycle ===&quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="linenos">185</span>
<span class="linenos">186</span><span class="w">  </span><span class="n">edge_list</span><span class="o">&lt;</span><span class="n">directedness</span><span class="o">::</span><span class="n">directed</span><span class="p">,</span><span class="w"> </span><span class="kt">double</span><span class="o">&gt;</span><span class="w"> </span><span class="n">edges2</span><span class="p">(</span><span class="mi">4</span><span class="p">);</span>
<span class="linenos">187</span><span class="w">  </span><span class="n">edges2</span><span class="p">.</span><span class="n">open_for_push_back</span><span class="p">();</span>
<span class="linenos">188</span><span class="w">  </span><span class="n">edges2</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mf">1.0</span><span class="p">);</span>
<span class="linenos">189</span><span class="w">  </span><span class="n">edges2</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mf">-1.0</span><span class="p">);</span>
<span class="linenos">190</span><span class="w">  </span><span class="n">edges2</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="mf">-1.0</span><span class="p">);</span>
<span class="linenos">191</span><span class="w">  </span><span class="n">edges2</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mf">-1.0</span><span class="p">);</span><span class="w">  </span><span class="c1">// Creates negative cycle: 1 -&gt; 2 -&gt; 3 -&gt; 1 (cost = -3)</span>
<span class="linenos">192</span><span class="w">  </span><span class="n">edges2</span><span class="p">.</span><span class="n">close_for_push_back</span><span class="p">();</span>
<span class="linenos">193</span>
<span class="linenos">194</span><span class="w">  </span><span class="k">auto</span><span class="w"> </span><span class="p">[</span><span class="n">success2</span><span class="p">,</span><span class="w"> </span><span class="n">distance2</span><span class="p">,</span><span class="w"> </span><span class="n">predecessor2</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">bellman_ford</span><span class="p">(</span><span class="n">edges2</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">weight_fn</span><span class="p">);</span>
<span class="linenos">195</span>
<span class="linenos">196</span><span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">success2</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="linenos">197</span><span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;No negative cycle found.&quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="linenos">198</span><span class="w">  </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span>
<span class="linenos">199</span><span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Negative cycle detected! (as expected)&quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="linenos">200</span><span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;The cycle 1 -&gt; 2 -&gt; 3 -&gt; 1 has total weight -3&quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="linenos">201</span><span class="w">  </span><span class="p">}</span>
<span class="linenos">202</span>
<span class="linenos">203</span><span class="w">  </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="linenos">204</span><span class="w">  </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Note: Bellman-Ford is O(V*E), slower than Dijkstra&#39;s O((V+E)log V),&quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="linenos">205</span><span class="w">  </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;but can handle negative weights and detect negative cycles.&quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="linenos">206</span>
<span class="linenos">207</span><span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="linenos">208</span><span class="p">}</span>
</pre></div>
</div>
</div>
</section>
<section id="building-and-running-the-example">
<h2>Building and Running the Example<a class="headerlink" href="#building-and-running-the-example" title="Link to this heading"></a></h2>
<p>First, configure and build the example:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span><span class="c1"># From the NWGraph root directory</span>
mkdir<span class="w"> </span>-p<span class="w"> </span>build<span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="nb">cd</span><span class="w"> </span>build
cmake<span class="w"> </span>..<span class="w"> </span>-DNWGRAPH_BUILD_EXAMPLES<span class="o">=</span>ON
make<span class="w"> </span>ch5_bellman_ford
</pre></div>
</div>
<p>Then run the example:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>./examples/bgl-book/ch5_bellman_ford
</pre></div>
</div>
<p>The program uses a sample router network and computes shortest paths using the Bellman-Ford
algorithm, demonstrating how distance-vector routing protocols work.</p>
</section>
<section id="sample-output">
<h2>Sample Output<a class="headerlink" href="#sample-output" title="Link to this heading"></a></h2>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>Router Network - Bellman-Ford Shortest Paths
Source: Router A

Router B: distance = 5ms, via Router A
Router C: distance = 1ms, via Router A
Router D: distance = 6.3ms, via Router B
...
No negative cycles detected.
</pre></div>
</div>
</section>
<section id="key-nwgraph-features-demonstrated">
<h2>Key NWGraph Features Demonstrated<a class="headerlink" href="#key-nwgraph-features-demonstrated" title="Link to this heading"></a></h2>
<ul class="simple">
<li><p><strong>Edge iteration</strong>: Processing all edges for relaxation</p></li>
<li><p><strong>Distance tracking</strong>: Recording shortest path distances</p></li>
<li><p><strong>Predecessor maps</strong>: Building the shortest-paths tree</p></li>
<li><p><strong>Negative cycle detection</strong>: Verifying solution validity</p></li>
</ul>
</section>
<section id="references">
<h2>References<a class="headerlink" href="#references" title="Link to this heading"></a></h2>
<ul class="simple">
<li><p>Cormen, Leiserson, Rivest, and Stein. <em>Introduction to Algorithms</em>, 4th Edition (2022),
<strong>Chapter 22.1: The Bellman-Ford Algorithm</strong></p></li>
<li><p>Siek, Lee, and Lumsdaine. <em>The Boost Graph Library</em> (2002), Chapter 5.3</p></li>
</ul>
</section>
<section id="see-also">
<h2>See Also<a class="headerlink" href="#see-also" title="Link to this heading"></a></h2>
<ul class="simple">
<li><p><a class="reference internal" href="ch5_dijkstra.html"><span class="doc">Internet Routing with Dijkstra’s Algorithm (BGL Book Chapter 5.4)</span></a> - Dijkstra’s algorithm for link-state routing</p></li>
<li><p><a class="reference internal" href="ch6_kruskal.html"><span class="doc">Kruskal’s Minimum Spanning Tree Algorithm (BGL Book Chapter 6)</span></a> - Minimum spanning trees</p></li>
<li><p><a class="reference internal" href="index.html"><span class="doc">Boost Graph Library Examples (Rewritten for NW Graph)</span></a> - BGL Book examples overview</p></li>
</ul>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="ch5_dijkstra.html" class="btn btn-neutral float-left" title="Internet Routing with Dijkstra’s Algorithm (BGL Book Chapter 5.4)" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="ch6_kruskal.html" class="btn btn-neutral float-right" title="Kruskal’s Minimum Spanning Tree Algorithm (BGL Book Chapter 6)" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2020-2022, PNNL, UW.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>