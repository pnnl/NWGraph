<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Generic Programming in C++20 &mdash; NW Graph 0.10.15 documentation</title>
      <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
      <link rel="stylesheet" href="../../_static/graphviz.css" type="text/css" />
      <link rel="stylesheet" href="../../_static/collapsible-lists/css/tree_view.css" type="text/css" />
      <link rel="stylesheet" href="../../_static/css/custom.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="../../" id="documentation_options" src="../../_static/documentation_options.js"></script>
        <script src="../../_static/jquery.js"></script>
        <script src="../../_static/underscore.js"></script>
        <script src="../../_static/doctools.js"></script>
        <script src="../../_static/collapsible-lists/js/CollapsibleLists.compressed.js"></script>
        <script src="../../_static/collapsible-lists/js/apply-collapsible-lists.js"></script>
    <script src="../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="../../index.html" class="icon icon-home"> NW Graph
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../getting_started.html">Quickstart</a></li>
<li class="toctree-l1"><a class="reference internal" href="../introduction.html">NWGraph: The Northwest Graph Library</a></li>
<li class="toctree-l1"><a class="reference internal" href="../graph-background-ii.html">Graph Background</a></li>
<li class="toctree-l1"><a class="reference internal" href="../generic-programming.html">Generic Programming in C++20</a></li>
<li class="toctree-l1"><a class="reference internal" href="../graph-concepts.html">Generic Graph Algorithms</a></li>
<li class="toctree-l1"><a class="reference internal" href="../algorithms.html">NWGraph Algorithms</a></li>
<li class="toctree-l1"><a class="reference internal" href="../adaptors.html">Graph Range Adaptors</a></li>
<li class="toctree-l1"><a class="reference internal" href="../data-structures.html">Model Data Structures</a></li>
<li class="toctree-l1"><a class="reference internal" href="../performance.html">Performance Evaluation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../related.html">Related Libraries and Toolkits</a></li>
<li class="toctree-l1"><a class="reference internal" href="../references.html">References Cited</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../examples/index.html">Examples</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../nwgraph_api.html">NWGraph API Reference</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">NW Graph</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../index.html" class="icon icon-home"></a> &raquo;</li>
      <li>Generic Programming in C++20</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../../_sources/userguide/old/generic-programming-background.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="generic-programming-in-c-20">
<span id="sec-generic-programming-background"></span><h1>Generic Programming in C++20<a class="headerlink" href="#generic-programming-in-c-20" title="Permalink to this headline"></a></h1>
<section id="generic-programming">
<span id="sec-gen-programming"></span><h2>Generic Programming<a class="headerlink" href="#generic-programming" title="Permalink to this headline"></a></h2>
<p>Generic programming is a software development paradigm inspired by the
organizational principles of
mathematics <a href="#id1"><span class="problematic" id="id2">:raw-latex:`\cite{stepanov2014mathematics}`</span></a>. That is, a
generic library comprises a framework of algorithms in a problem domain,
based on a systematic organization of common type requirements for those
algorithms. The type requirements themselves, specified as <em>concepts</em>
are part of the library as well, and provide the interface that enables
composition of library components with other, independently-developed,
components. The <code class="docutils literal notranslate"><span class="pre">iterator</span></code> concept taxonomy, for example, was the
foundation upon which the STL was
organized <a href="#id3"><span class="problematic" id="id4">:raw-latex:`\citep{STL,Musser89}`</span></a>.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span><span class="w"> </span><span class="nf">sum</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="n">array</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">n</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">s</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">n</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">s</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">s</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">array</span><span class="p">[</span><span class="n">i</span><span class="p">];</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">s</span><span class="p">;</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">double</span><span class="w"> </span><span class="nf">sum</span><span class="p">(</span><span class="n">node</span><span class="w"> </span><span class="o">*</span><span class="n">bgn</span><span class="p">,</span><span class="w"> </span><span class="n">node</span><span class="w"> </span><span class="o">*</span><span class="n">end</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="kt">double</span><span class="w"> </span><span class="n">s</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="n">bgn</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">end</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">s</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">s</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">bgn</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">bgn</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">bgn</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">next</span><span class="p">;}</span><span class="w"></span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">s</span><span class="p">;</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>Generic algorithms (that is, algorithms in a generic library) are
designed so that the requirements they impose on types are as minimal as
possible without compromising efficiency, thus enabling the widest scope
of potential composition, and therefore, reuse. Generic algorithms are
derived from concrete ones, which are gradually made more generic by
removing (“lifting”) unnecessary requirements. This process continues as
long as instantiation of the generic algorithm with concrete types
remains as efficient as the equivalent concrete algorithm would have
been. Generic libraries do not tolerate abstraction penalty.</p>
<p>We emphasize again that in a generic library, the requirements on
algorithms lead to the concepts, which in turn represent the interface
to the library. The goal is to create an efficient framework of
highly-reusable algorithms that can be composed with arbitrary
third-party components – <em>not</em> to start with a data type intended to
meet all needs (even in the guise of a concept) and then define
conforming algorithms.</p>
</section>
<section id="the-generic-programming-process">
<h2>The Generic Programming Process<a class="headerlink" href="#the-generic-programming-process" title="Permalink to this headline"></a></h2>
<section id="lifting">
<h3>Lifting<a class="headerlink" href="#lifting" title="Permalink to this headline"></a></h3>
<p>The first (and major) phase of the generic programming process is
sometimes known as “lifting“ where we create generic algorithms through
a process of successive generaliation. That is, the process is</p>
<ol class="arabic simple">
<li><p>Study the concrete implementation of an algorithm</p></li>
<li><p>Lift away unnecessary requirements to produce a more abstract
algorithm</p></li>
<li><p>Repeat the lifting process until we have obtained a generic algorithm
that is as general as possible but that still instantiates to
efficient concrete implementations</p></li>
<li><p>Catalog remaining requirements and organize them into concepts</p></li>
</ol>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">class</span><span class="w"> </span><span class="nc">Iter</span><span class="p">,</span><span class="w"> </span><span class="k">class</span><span class="w"> </span><span class="nc">T</span><span class="o">&gt;</span><span class="w"></span>
<span class="n">T</span><span class="w"> </span><span class="n">sum</span><span class="p">(</span><span class="n">Iter</span><span class="w"> </span><span class="n">first</span><span class="p">,</span><span class="w"> </span><span class="n">Iter</span><span class="w"> </span><span class="n">last</span><span class="p">,</span><span class="w"></span>
<span class="w">      </span><span class="n">T</span><span class="w"> </span><span class="n">s</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="n">first</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">last</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">s</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">s</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="o">*</span><span class="n">first</span><span class="o">++</span><span class="p">;}</span><span class="w"></span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">s</span><span class="p">;</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">class</span><span class="w"> </span><span class="nc">Iter</span><span class="p">,</span><span class="w"> </span><span class="k">class</span><span class="w"> </span><span class="nc">T</span><span class="p">,</span><span class="w"> </span><span class="k">class</span><span class="w"> </span><span class="nc">Op</span><span class="o">&gt;</span><span class="w"></span>
<span class="n">T</span><span class="w"> </span><span class="n">accumulate</span><span class="p">(</span><span class="n">Iter</span><span class="w"> </span><span class="n">first</span><span class="p">,</span><span class="w"> </span><span class="n">Iter</span><span class="w"> </span><span class="n">last</span><span class="p">,</span><span class="w"></span>
<span class="w">             </span><span class="n">T</span><span class="w"> </span><span class="n">s</span><span class="p">,</span><span class="w"> </span><span class="n">Op</span><span class="w"> </span><span class="n">op</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="n">first</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">last</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">s</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">op</span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="w"> </span><span class="o">*</span><span class="n">first</span><span class="o">++</span><span class="p">);</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">s</span><span class="p">;</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>Fig. <a class="reference external" href="#fig:sum">[fig:sum]</a> shows two concrete implementations of a
<code class="docutils literal notranslate"><span class="pre">sum</span></code> algorithm. The first steps through an array of integers,
indexing into the array at each step and summing the resulting value
into <code class="docutils literal notranslate"><span class="pre">s</span></code>. The second “cdrs” through a linked list of <code class="docutils literal notranslate"><span class="pre">node</span></code>
structures, obtaining the value stored in the <code class="docutils literal notranslate"><span class="pre">data</span></code> field and summing
the obtained value into <code class="docutils literal notranslate"><span class="pre">s</span></code>.</p>
<p>The authors of the STL realized the commonality of traversal and element
access across most basic computer science algorithms. The requirements
for traversal and access were generalized and unified into a hierarchy
of type requirements known as iterators <a href="#id5"><span class="problematic" id="id6">:raw-latex:`\cite{STL}`</span></a>.</p>
<p>An iterator-based algorithm for summing elements in a container is shown
in Fig. <a class="reference external" href="#fig:accum">[fig:accum]</a> (left). Note that this single
parameterized algorithm replaces the <code class="docutils literal notranslate"><span class="pre">sum</span></code> algorithms shown in
Fig. <a class="reference external" href="#fig:sum">[fig:sum]</a> (and more). The process of summation can
further be generalized by the introduction of function objects, as is
shown in lifting <code class="docutils literal notranslate"><span class="pre">sum</span></code> to <code class="docutils literal notranslate"><span class="pre">accumulate</span></code> in the right of
Fig. <a class="reference external" href="#fig:accum">[fig:accum]</a>.</p>
</section>
<section id="specialization">
<h3>Specialization<a class="headerlink" href="#specialization" title="Permalink to this headline"></a></h3>
<p>In generic programming, the dual to lifting is <em>specialization.</em> That
is, once an algorithm is lifted and made generic, it is specialized
through composition with a concrete data type to realize a concrete
implementation of the algorithm. Fig. <a class="reference external" href="#fig:spec">[fig:spec]</a> shows
two examples of usage of the generic <code class="docutils literal notranslate"><span class="pre">sum</span></code> and <code class="docutils literal notranslate"><span class="pre">accumulate</span></code> that we
created, composing them with the original data structures we lifted
from. We note that the linked list example uses the equivalent
linked-list implementation from the standard library, as that provides
the necessary iterator interfaces for the generic algorithms to use.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span><span class="o">*</span><span class="w"> </span><span class="n">array</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="p">[</span><span class="mi">10</span><span class="p">];</span><span class="w"></span>
<span class="kt">int</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="o">=</span><span class="w"></span>
<span class="w">    </span><span class="n">sum</span><span class="p">(</span><span class="n">array</span><span class="p">,</span><span class="w"> </span><span class="n">array</span><span class="o">+</span><span class="mi">10</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">std</span><span class="o">::</span><span class="n">forward_list</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="w"> </span><span class="n">ptr</span><span class="p">;</span><span class="w"></span>
<span class="kt">double</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">accumulate</span><span class="p">(</span><span class="n">ptr</span><span class="p">,</span><span class="w"> </span><span class="k">nullptr</span><span class="p">,</span><span class="w"></span>
<span class="w">                </span><span class="mf">0.0</span><span class="p">,</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">times</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>Now, there is a crucial requirement that is part of specialization. In
generic programming, we don’t just require that when we have a lifted
algorithm that we can compose with the data types that we lifted from.
In addition to that basic requirement, we also require that <em>there is
zero abstraction penalty</em>. That is, the specialized generic algorithm
should provide exactly the same performance as the concrete algorithm
from which it was lifted, when composed with the original types that
were lifted. With modern compilers and libraries, this requirement is
actually met, and is one of the reasons that libraries such as the C++
standard library have been so successful in practice.</p>
</section>
</section>
<section id="concepts-in-c-20">
<h2>Concepts in C++20<a class="headerlink" href="#concepts-in-c-20" title="Permalink to this headline"></a></h2>
<p>In generic programming, concepts consist of valid expressions and
associated types, which define a family of allowable types admissable
for composition with generic algorithms. Introduced as a language
feature for C++20, concepts are an extension of templates that constrain
the set of types that can be substituted for class and function template
arguments. Concepts formalize and make explicit—-at the language
level—-properties about types that were previously informal and/or
implicit. This development has been instrumental in the notable
development of the ranges algorithm library taxonomy, serving as the
link between generic algorithm interface and implementation.</p>
<p>A <code class="docutils literal notranslate"><span class="pre">concept</span></code> definition declares a set of requirements on types. There
are four types of requirements:</p>
<ul class="simple">
<li><p>A simple requirement is an arbitrary expression statement. The
requirement is that the expression is valid.</p></li>
<li><p>A type requirement is the keyword <code class="docutils literal notranslate"><span class="pre">typename</span></code> followed by a type
name, optionally qualified. The requirement is that the named type
exists.</p></li>
<li><p>A compound requirement specifies a conjunction of arbitrary
constraints such as expression constraint, exception constraint, and
type constraint, etc.</p></li>
<li><p>A nested requirement is another requires-clause, terminated with a
semicolon. This is used to introduce predicate constraints expressed
in terms of other named concepts applied to the local parameters.</p></li>
</ul>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="linenos">1</span>template &lt;class I&gt;
<span class="linenos">2</span>concept proto_input_iterator =
<span class="linenos">3</span>  requires(I i) {
<span class="linenos">4</span>    typename std::iter_value_t&lt;I&gt;;
<span class="linenos">5</span>    typename std::iter_reference_t&lt;I&gt;;
<span class="linenos">6</span>    { *i } -&gt; std::same_as&lt;std::iter_reference_t&lt;I&gt;&gt;; !\label{code:iterator:dereference}!
<span class="linenos">7</span>    { ++i } -&gt; std::same_as&lt;I&amp;&gt;; !\label{code:iterator:postincrement}!
<span class="linenos">8</span>    i++;!\label{code:iterator:preincrement}!  };
</pre></div>
</div>
<p>Fig. <a class="reference external" href="#fig:iterator-concepts">[fig:iterator-concepts]</a> shows the
skeleton of the C++ concept definition for <code class="docutils literal notranslate"><span class="pre">input_iterator</span></code>. As hinted
in our example, this concept specifies that an <code class="docutils literal notranslate"><span class="pre">input_iterator</span></code> can be
de-referenced with <code class="docutils literal notranslate"><span class="pre">operator*</span></code>
(line <a class="reference external" href="#code:iterator:dereference">[code:iterator:dereference]</a>) and
incremented with <code class="docutils literal notranslate"><span class="pre">operator++</span></code>
(lines <a class="reference external" href="#code:iterator:postincrement">[code:iterator:postincrement]</a>
and <a class="reference external" href="#code:iterator:preincrement">[code:iterator:preincrement]</a>).
Additionally, the concept specifies two associated types:
<code class="docutils literal notranslate"><span class="pre">std::iter_value_t&lt;I&gt;</span></code> and <code class="docutils literal notranslate"><span class="pre">std::iter_reference_t&lt;I&gt;</span></code>.
Line <a class="reference external" href="#code:iterator:dereference">[code:iterator:dereference]</a> also
indicates that the expression <code class="docutils literal notranslate"><span class="pre">*i</span></code> returns the same type as
<code class="docutils literal notranslate"><span class="pre">std::iter_reference_t&lt;I&gt;</span></code>. Again, this example is abbreviated for
purposes of illustration. A complete description of the C++20 standard
library concepts (including the iterator hierarchy) can be found online
at <code class="docutils literal notranslate"><span class="pre">https://en.cppreference.com/w/cpp/concepts</span></code>.</p>
<p><strong>Remark.</strong> C++20 concepts are similar to type constraints in D
programming language. They are a way to constrain the types allowed
based on their properties. Concepts, as type constraints, support static
checking of instantiations during compilation time. If the concepts are
not specified for a template type, any type passed as an argument would
be valid at compilation time, and can potentially result in a run-time
error if the type does not meet certain properties. Ideas that are
closely related to concepts exist in other languages too, such as
Haskell typeclasses, Rust traits, Swift protocols, etc. However, a
subtle difference between these features and concepts is that these
“type classes” are a form of “consent”, rather than
“constraints” <a href="#id7"><span class="problematic" id="id8">:raw-latex:`\citep{conorconcepts}`</span></a>. A more detailed
discussion about the differences between (pre-C++20) concepts and
Haskell type classes can be found
in <a href="#id9"><span class="problematic" id="id10">:raw-latex:`\citep{bernardy2010generic}`</span></a>. An extensive comparative
study on support for generic programming in a variety of different
languages can be found in
 <a href="#id11"><span class="problematic" id="id12">:raw-latex:`\citep{garcia03:_comparative_study}`</span></a>, which was
subsequently extended to eight languages
in <a href="#id13"><span class="problematic" id="id14">:raw-latex:`\citep{garcia07:_extended_comparative_study}`</span></a>.</p>
</section>
<section id="ranges-in-c-20">
<h2>Ranges in C++20<a class="headerlink" href="#ranges-in-c-20" title="Permalink to this headline"></a></h2>
<p>Essentially, ranges can be considered to be an abstraction of the notion
of a container, i.e., a collection of items that can be iterated over.
The new C++20 Ranges library <a href="#id15"><span class="problematic" id="id16">:raw-latex:`\citep{niebler2018one}`</span></a> adds
support for operating on ranges of elements. Ranges provide a way to
make STL algorithms <em>composable</em> and improve the readability and
writability of C++ code. Ranges consist of a pair of begin and end
iterators that are not required to be the same type. An example of using
<code class="docutils literal notranslate"><span class="pre">ranges</span></code> is:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">v</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="cm">/* ... */</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
<span class="n">std</span><span class="o">::</span><span class="n">min_element</span><span class="p">(</span><span class="n">v</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span><span class="w"> </span><span class="n">v</span><span class="p">.</span><span class="n">end</span><span class="p">());</span><span class="w">    </span><span class="c1">// iterator interface</span>
<span class="n">std</span><span class="o">::</span><span class="n">ranges</span><span class="o">::</span><span class="n">min_element</span><span class="p">(</span><span class="n">v</span><span class="p">);</span><span class="w">             </span><span class="c1">// ranges interface</span>
</pre></div>
</div>
<p>In the first case, the generic <code class="docutils literal notranslate"><span class="pre">min_element</span></code> function is called with
an iterator pair (<code class="docutils literal notranslate"><span class="pre">begin</span></code> and <code class="docutils literal notranslate"><span class="pre">end</span></code> of the container <code class="docutils literal notranslate"><span class="pre">v</span></code>). In the
second case, <code class="docutils literal notranslate"><span class="pre">min_element</span></code> function is called directly with <code class="docutils literal notranslate"><span class="pre">v</span></code> as
the parameter, as a <code class="docutils literal notranslate"><span class="pre">std::vector</span></code> is a range (specifically, it
satisfies the requirements for the <code class="docutils literal notranslate"><span class="pre">random_access_range</span></code> concept.</p>
<p>C++20 ranges are defined in terms of C++20 concepts. A <code class="docutils literal notranslate"><span class="pre">std::range</span></code>
itself is a very straightforward concept:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">template</span><span class="o">&lt;</span><span class="w"> </span><span class="k">class</span><span class="w"> </span><span class="nc">T</span><span class="w"> </span><span class="o">&gt;</span><span class="w"></span>
<span class="k">concept</span><span class="w"> </span><span class="nc">range</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">requires</span><span class="p">(</span><span class="n">T</span><span class="o">&amp;</span><span class="w"> </span><span class="n">t</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="n">ranges</span><span class="o">::</span><span class="n">begin</span><span class="p">(</span><span class="n">t</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="n">ranges</span><span class="o">::</span><span class="n">end</span><span class="w">  </span><span class="p">(</span><span class="n">t</span><span class="p">);</span><span class="w"> </span><span class="p">};</span><span class="w"></span>
</pre></div>
</div>
<p>It has two valid expressions: <code class="docutils literal notranslate"><span class="pre">begin</span></code> and <code class="docutils literal notranslate"><span class="pre">end</span></code>. The
<code class="docutils literal notranslate"><span class="pre">std::input_range</span></code>, which abstracts containers that have forward
iterators, is thus defined:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span><span class="w"> </span><span class="nc">T</span><span class="o">&gt;</span><span class="w"></span>
<span class="k">concept</span><span class="w"> </span><span class="nc">input_range</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ranges</span><span class="o">::</span><span class="n">range</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"></span>
<span class="w">    </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">input_iterator</span><span class="o">&lt;</span><span class="n">ranges</span><span class="o">::</span><span class="n">iterator_t</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&gt;</span><span class="p">;</span><span class="w"></span>
</pre></div>
</div>
<p>This definition states that an <code class="docutils literal notranslate"><span class="pre">input_range</span></code> is a <code class="docutils literal notranslate"><span class="pre">range</span></code> and that
furthermore, the iterator type associated with that range meets the
requirements of the <code class="docutils literal notranslate"><span class="pre">std::input_iterator</span></code> concept.</p>
<p>Related to graphs, two range concepts of particular relevance include
<code class="docutils literal notranslate"><span class="pre">ranges::forward_range</span></code>, which allows iteration over a collection from
beginning to end multiple times (as opposed to an input iterator which
is only guaranteed to be able to iterator over a collection once) and
<code class="docutils literal notranslate"><span class="pre">ranges::random_access_range</span></code>, which further allows indexing into a
collection with <code class="docutils literal notranslate"><span class="pre">operator[]</span></code> in constant time.</p>
<p><em>Range adaptors</em>, alternatively known as <em>views</em>, can be considered as
wrappers around another range, without mutating or copying the original
range.</p>
</section>
</section>


           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2020-2022, PNNL, UW.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>